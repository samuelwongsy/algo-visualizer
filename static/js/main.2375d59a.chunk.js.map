{"version":3,"sources":["images/snowflake.svg","components/PathFindingVisualizer/PathFindingGrid/Node/Node.jsx","components/PathFindingVisualizer/PathFindingGrid/PathFindingGrid.jsx","components/PathFindingVisualizer/SideMenu.jsx","algorithms/path-finding-algorithms/breath-first-search.js","algorithms/path-finding-algorithms/a-star-search-queue.js","algorithms/path-finding-algorithms/a-star-search.js","algorithms/data-structures/MinHeap.js","algorithms/path-finding-algorithms/depth-first-search.js","algorithms/maze-generation-algorithms/recursive-division.js","algorithms/maze-generation-algorithms/binary-tree-maze.js","algorithms/maze-generation-algorithms/depth-first-search-maze.js","components/PathFindingVisualizer/PathFindingVisualizer.jsx","components/NavigationBar.jsx","components/HomePage.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","props","row","col","isFinish","isStart","isWall","isVisited","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","PathFindingGrid","useState","mouseDown","setMouseDown","grid","setGrid","getNewGridWithWallToggled","handleClick","newGrid","map","rowIndex","key","node","colIndex","visitedClass","handleMouseDown","handleMouseEnter","onClick","SideMenu","state","activeItem","activeWall","handleItemClick","e","name","setState","handleSelection","handleWallAlgoClick","mazeFlag","clearFlag","handleWallGeneration","clearGrid","this","visualizeAlgorithm","animateFlag","Menu","fluid","inverted","vertical","size","Item","active","Button","secondary","icon","labelPosition","disabled","Icon","Component","updateUnvisitedNeighbours","queue","unvisitedNeighbours","neighbours","push","length","filter","getUnvisitedNeighbours","neighbour","previousNode","bfs","FINISH_NODE_ROW","FINISH_NODE_COL","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","currentNode","shift","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","getHeuristics","Math","abs","updateNeighbours","getNeighbours","tentativeGScore","gScore","distance","includes","sort","a","b","aStarSearch","openNodes","MinHeap","array","heap","buildHeap","currentIdx","floor","siftDown","endIdx","childOneIdx","childTwoIdx","idxToSwap","swap","parentIdx","valueToRemove","pop","value","siftUp","i","j","temp","minHeap","insert","remove","stack","dfs","getRandomInt","min","max","result","random","flag","recursiveDivision","wallNodesInOrder","wallNodesSet","Set","endRow","endCol","add","divisionHelper","startRow","startCol","typeOfDivide","height","width","tries","override","openRowOverride","has","openRow","openColOverride","openCol","connect","neighbourNode","binaryTreeMaze","nodesInOrder","randomIndex","getUnvisitedNeighboursInRandomOrder","isExplored","randomNode","previousExploredNode","splice","depthFirstSearchMaze","PathFindingVisualizer","getInitialGrid","algoString","setAlgoString","setAnimateFlag","setMazeFlag","setClearFlag","useReducer","algoReducer","algorithm","dispatch","useEffect","type","animateAlgorithm","setTimeout","animateShortestPath","document","getElementById","animateNodeAlgo","animateFullWalls","isIncreasing","lastRow","lastCol","node1","node2","newGrid1","newGrid2","animateWallAlgo","Grid","verticalAlign","Column","floated","Container","newAlgoString","copyOfGrid","wallString","startWithWalls","wallAlgo","ceil","currentRow","createNode","Infinity","fScore","action","aStarSearchMinHeap","newNode","NavigationBar","fixed","as","href","header","Image","src","require","style","marginRight","HomePage","divided","backgroundColor","Row","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.2375d59a.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/snowflake.6114f6e9.svg\";","import React, { useState } from \"react\";\nimport \"./Node.css\";\n\nfunction Node(props) {\n  const {\n    row,\n    col,\n    isFinish,\n    isStart,\n    isWall,\n    isVisited,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n  } = props;\n\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : isVisited\n    ? \"node-visited\"\n    : \"\";\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseUp={() => onMouseUp()}\n    ></div>\n  );\n}\n\nexport default Node;\n","import React, { useState, useEffect } from \"react\";\nimport Node from \"./Node/Node\";\nimport \"./PathFindingGrid.css\";\n\nfunction PathFindingGrid(props) {\n  const [mouseDown, setMouseDown] = useState(false);\n  const { grid, setGrid, getNewGridWithWallToggled } = props;\n\n  // useEffect(() => {\n  //   for (let row = 0; row < grid.length; row++) {\n  //     for (let col = 0; col < grid[0].length; col++) {\n  //       document.getElementById(`node-${row}-${col}`).className = \"node\";\n  //     }\n  //   }\n  // }, [grid]);\n\n  const handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setMouseDown(true);\n    setGrid(newGrid);\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseDown) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseDown(false);\n  };\n\n  const handleClick = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  return (\n    <div>\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => {\n          return (\n            <div key={rowIndex} className=\"row\">\n              {row.map((node, colIndex) => (\n                <Node\n                  key={[node.col, node.row]}\n                  isStart={node.isStart}\n                  isFinish={node.isFinish}\n                  isWall={node.isWall}\n                  isVisited={node.visitedClass}\n                  // mousePressed={mouseDown}\n                  onMouseDown={(row, col) => handleMouseDown(row, col)}\n                  onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                  onMouseUp={() => handleMouseUp()}\n                  onClick={handleClick}\n                  row={node.row}\n                  col={node.col}\n                />\n              ))}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\n\nexport default PathFindingGrid;\n","import React, { Component } from \"react\";\nimport { Menu, Button, Icon } from \"semantic-ui-react\";\n\nexport default class SideMenu extends Component {\n  state = { \n    activeItem: \"Breadth First Search\",\n    activeWall: \"Default\"\n  };\n\n  handleItemClick = (e, { name }) => {\n    this.setState({ activeItem: name });\n    this.props.handleSelection(name);\n  };\n\n  handleWallAlgoClick = (e, { name }) => {\n    if (this.props.mazeFlag || !this.props.clearFlag) return;\n    this.setState({ activeWall: name });\n    this.props.handleWallGeneration(name);\n  }\n\n  clearGrid = (e) => {\n    this.setState({ activeWall: \"Default\" });\n    this.props.clearGrid();\n  }\n\n  render() {\n    const { activeItem, activeWall } = this.state;\n    const { visualizeAlgorithm, clearGrid, animateFlag, clearFlag } = this.props;\n\n    return (\n      <Menu fluid inverted vertical size=\"large\">\n        <Menu.Item>\n          Algorithms\n          <Menu.Menu>\n            <Menu.Item\n              name=\"Breadth First Search\"\n              active={activeItem === \"Breadth First Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"Depth First Search\"\n              active={activeItem === \"Depth First Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"A-star Search\"\n              active={activeItem === \"A-star Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"A-star Search Min Heap\"\n              active={activeItem === \"A-star Search Min Heap\"}\n              onClick={this.handleItemClick}\n            />\n          </Menu.Menu>\n        </Menu.Item>\n\n        <Menu.Item>\n          Wall Generation\n          <Menu.Menu>\n            <Menu.Item \n              name=\"Recursive Division\"\n              active={activeWall === \"Recursive Division\"}\n              onClick={this.handleWallAlgoClick}\n            />\n            <Menu.Item \n              name=\"Binary Tree Maze\"\n              active={activeWall === \"Binary Tree Maze\"}\n              onClick={this.handleWallAlgoClick}\n            />\n            <Menu.Item \n              name=\"Depth First Search Maze\"\n              active={activeWall === \"Depth First Search Maze\"}\n              onClick={this.handleWallAlgoClick}\n            />\n          </Menu.Menu>\n        </Menu.Item>\n\n        {/* <Menu.Item\n          name=\"home\"\n          active={activeItem === \"home\"}\n          onClick={this.handleItemClick}\n        />\n        <Menu.Item\n          name=\"messages\"\n          active={activeItem === \"messages\"}\n          onClick={this.handleItemClick}\n        />\n        <Menu.Item\n          name=\"friends\"\n          active={activeItem === \"friends\"}\n          onClick={this.handleItemClick}\n        /> */}\n        <Menu.Item>\n          <Button\n            fluid\n            secondary\n            icon\n            labelPosition=\"right\"\n            onClick={visualizeAlgorithm}\n            disabled={animateFlag || (!animateFlag && !clearFlag)}\n          >\n            Visualize\n            <Icon name=\"caret square right\" />\n          </Button>\n        </Menu.Item>\n        <Menu.Item>\n          <Button\n            fluid\n            secondary\n            icon\n            labelPosition=\"right\"\n            onClick={this.clearGrid}\n            disabled={animateFlag}\n          >\n            Clear\n            <Icon name=\"redo alternate\" />\n          </Button>\n        </Menu.Item>\n      </Menu>\n    );\n  }\n}\n","// Breath-first search using a queue\n\nfunction bfs(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = []; // queue\n  unvisitedNodes.push(startNode);\n\n  while (!!unvisitedNodes.length) {\n    const currentNode = unvisitedNodes.shift();\n\n    if (currentNode.isWall) continue;\n\n    if (currentNode.isVisited) continue;\n\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === finishNode) break;\n\n    updateUnvisitedNeighbours(currentNode, unvisitedNodes, grid);\n  }\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n  // console.log(visitedNodesInOrder);\n\n  return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction updateUnvisitedNeighbours(node, queue, grid) {\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of unvisitedNeighbours) {\n    neighbour.previousNode = node;\n    queue.push(neighbour);\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const {\n    col,\n    row\n  } = node;\n\n  const neighbours = [];\n\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n  return neighbours.filter(node => !node.isVisited);\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n  if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nexport default bfs;","// a-star search using manhatten distance heuristics\n// not using visited because a-star search allows you to reach a visited node with\n// a lower distance\n\nlet FINISH_NODE_ROW;\nlet FINISH_NODE_COL;\n\nfunction aStarSearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n\n    FINISH_NODE_ROW = finishNode.row;\n    FINISH_NODE_COL = finishNode.col;\n\n    const visitedNodesInOrder = [];\n    const openNodes = [];\n    openNodes.push(startNode);\n    while (!!openNodes.length) {\n        const currentNode = openNodes.shift();\n\n        if (currentNode === startNode) {\n            currentNode.gScore = 0;\n            currentNode.distance = getHeuristics(currentNode);\n        }\n\n        if (currentNode.isWall) continue;\n\n        visitedNodesInOrder.push(currentNode);\n\n        if (currentNode === finishNode) {\n            finishNode.isVisited = true;\n            break;\n        }\n\n        updateNeighbours(currentNode, openNodes, grid);\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    // console.log(visitedNodesInOrder);\n\n    return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction getHeuristics(node) {\n    const distance = Math.abs(node.row - FINISH_NODE_ROW) +\n        Math.abs(node.col - FINISH_NODE_COL);\n\n    return distance\n}\n\nfunction updateNeighbours(node, queue, grid) {\n    const neighbours = getNeighbours(node, grid);\n\n    for (const neighbour of neighbours) {\n        const tentativeGScore = node.gScore + 1;\n        if (tentativeGScore < neighbour.gScore) {\n            neighbour.previousNode = node;\n            neighbour.gScore = tentativeGScore;\n            neighbour.distance = neighbour.gScore + getHeuristics(neighbour);\n            if (!queue.includes(neighbour)) queue.push(neighbour);\n        }\n    }\n    queue.sort((a, b) => a.distance - b.distance);\n}\n\nfunction getNeighbours(node, grid) {\n    const {\n        col,\n        row\n    } = node;\n\n    const neighbours = [];\n\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n    return neighbours;\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n    // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n    if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport default aStarSearch;","import MinHeap from '../data-structures/MinHeap';\n// a-star search using manhatten distance heuristics\n// not using visited because a-star search allows you to reach a visited node with\n// a lower distance\n\nlet FINISH_NODE_ROW;\nlet FINISH_NODE_COL;\n\nfunction aStarSearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n\n    FINISH_NODE_ROW = finishNode.row;\n    FINISH_NODE_COL = finishNode.col;\n\n    const visitedNodesInOrder = [];\n    const openNodes = new MinHeap([]);\n    openNodes.insert(startNode);\n    while (!!openNodes.heap.length) {\n        // console.log(openNodes.heap);\n        const currentNode = openNodes.remove();\n\n        if (currentNode === startNode) {\n            currentNode.gScore = 0;\n            currentNode.distance = getHeuristics(currentNode);\n        }\n\n        if (currentNode.isWall) continue;\n\n        visitedNodesInOrder.push(currentNode);\n\n        if (currentNode === finishNode) {\n            finishNode.isVisited = true;\n            break;\n        }\n\n        updateNeighbours(currentNode, openNodes, grid);\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    // console.log(visitedNodesInOrder);\n\n    return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction getHeuristics(node) {\n    const distance = Math.abs(node.row - FINISH_NODE_ROW) +\n        Math.abs(node.col - FINISH_NODE_COL);\n\n    return distance\n}\n\nfunction updateNeighbours(node, minHeap, grid) {\n    const neighbours = getNeighbours(node, grid);\n\n    for (const neighbour of neighbours) {\n        const tentativeGScore = node.gScore + 1;\n        if (tentativeGScore < neighbour.gScore) {\n            neighbour.previousNode = node;\n            neighbour.gScore = tentativeGScore;\n            neighbour.distance = neighbour.gScore + getHeuristics(neighbour);\n            if (!minHeap.heap.includes(neighbour)) minHeap.insert(neighbour);\n        }\n    }\n}\n\nfunction getNeighbours(node, grid) {\n    const {\n        col,\n        row\n    } = node;\n\n    const neighbours = [];\n\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n    return neighbours;\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n    // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n    if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport default aStarSearch;","class MinHeap {\n    constructor(array) {\n        this.heap = this.buildHeap(array);\n    }\n\n    // O(n) time | O(1) space\n    buildHeap(array) {\n        const firstParentIdx = Math.floor((array.length - 2) / 2);\n        for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n            this.siftDown(currentIdx, array.length - 1, array);\n        }\n        return array;\n\n    }\n\n    // O(log(n)) time | O(1) space\n    siftDown(currentIdx, endIdx, heap) {\n        let childOneIdx = currentIdx * 2 + 1;\n        while (childOneIdx <= endIdx) {\n            const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n            let idxToSwap;\n            if (childTwoIdx !== -1 && heap[childTwoIdx].distance < heap[childOneIdx].distance) {\n                idxToSwap = childTwoIdx;\n            } else {\n                idxToSwap = childOneIdx;\n            }\n            if (heap[idxToSwap].distance < heap[currentIdx].distance) {\n                this.swap(currentIdx, idxToSwap, heap);\n                currentIdx = idxToSwap;\n                childOneIdx = currentIdx * 2 + 1;\n            } else {\n                return;\n            }\n        }\n\n    }\n\n    // O(log(n)) time | O(1) space\n    siftUp(currentIdx, heap) {\n        let parentIdx = Math.floor((currentIdx - 1) / 2);\n        while (currentIdx > 0 && heap[currentIdx].distance < heap[parentIdx].distance) {\n            this.swap(currentIdx, parentIdx, heap);\n            currentIdx = parentIdx;\n            parentIdx = Math.floor((currentIdx - 1) / 2);\n        }\n    }\n\n    // O(1) time | O(1) space\n    peek() {\n        return this.heap[0];\n    }\n\n    // O(log(n)) time | O(1) space\n    remove() {\n        this.swap(0, this.heap.length - 1, this.heap);\n        const valueToRemove = this.heap.pop();\n        this.siftDown(0, this.heap.length - 1, this.heap);\n        return valueToRemove;\n    }\n\n    // O(log(n)) time | O(1) space\n    insert(value) {\n        this.heap.push(value);\n        this.siftUp(this.heap.length - 1, this.heap);\n    }\n\n    swap(i, j, heap) {\n        const temp = heap[j];\n        heap[j] = heap[i];\n        heap[i] = temp;\n    }\n}\n\n// Do not edit the line below.\nexport default MinHeap;","// Depth-first search using a stack\n\nfunction dfs(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n\n    const visitedNodesInOrder = [];\n    const unvisitedNodes = []; //stack\n    unvisitedNodes.push(startNode);\n\n    while (!!unvisitedNodes.length) {\n        const currentNode = unvisitedNodes.pop();\n\n        if (currentNode.isWall) continue;\n\n        if (currentNode.isVisited) continue;\n\n        currentNode.isVisited = true;\n        visitedNodesInOrder.push(currentNode);\n\n        if (currentNode === finishNode) break;\n\n        updateUnvisitedNeighbours(currentNode, unvisitedNodes, grid);\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n    return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction updateUnvisitedNeighbours(node, stack, grid) {\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n    for (const neighbour of unvisitedNeighbours) {\n        neighbour.previousNode = node;\n        stack.push(neighbour);\n    }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n    const {\n        col,\n        row\n    } = node;\n\n    const neighbours = [];\n\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n    return neighbours.filter(node => !node.isVisited);\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n    // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n    if (!finishNode.isVisited && !finishNode.previousNode) return [];\n  \n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport default dfs;","function recursiveDivision(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [grid, []];\n    }\n    const newGrid = grid;\n    const wallNodesInOrder = [];\n    const wallNodesSet = new Set();\n    \n    const startRow = 0;\n    const startCol = 0;\n    const endRow = grid.length-1;\n    const endCol = grid[0].length-1;\n    // inital boundary\n    for (let col = 0; col < grid[0].length; col++) {\n        const currentNode = grid[0][col];\n        wallNodesInOrder.push(currentNode);\n        wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n\n    for (let row = 1; row < grid.length-1; row++) {\n        const currentNode = grid[row][endCol];\n        wallNodesInOrder.push(currentNode);\n        wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n\n    for (let col = endCol; col >= 0; col--) {\n        const currentNode = grid[endRow][col];\n        wallNodesInOrder.push(currentNode);\n        wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n\n    for (let row = endRow - 1; row > 0; row--) {\n        const currentNode = grid[row][startCol];\n        wallNodesInOrder.push(currentNode);\n        wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n\n    divisionHelper(newGrid, startRow+1, endRow-1, startCol+1, endCol-1, wallNodesInOrder, wallNodesSet);\n\n    return [newGrid, wallNodesInOrder]\n}\n\nfunction divisionHelper(grid, startRow, endRow, startCol, endCol, wallNodesInOrder, wallNodesSet) {\n    // if (startRow >= endRow - 2) return;\n    // if (startCol >= endCol - 2) return;\n\n    const height = endRow - startRow;\n    const width = endCol - startCol;\n\n    if (height <= 1 && width <= 1) return;\n    \n    let typeOfDivide;\n    if (width >= height) {\n        typeOfDivide = 'vertical';\n    } else {\n        typeOfDivide = 'horizontal';\n    }\n\n    if (height === 3 && typeOfDivide === 'vertical') {\n        typeOfDivide = 'horizontal';\n    } else if (width === 3 && typeOfDivide === 'horizontal') {\n        typeOfDivide = 'vertical';\n    }\n\n    if (typeOfDivide === 'vertical') {\n        let col = getRandomInt(startCol+1, endCol-1), tries = 10;\n        let override = false, openRowOverride = -1;\n        while (!(wallNodesSet.has(`${startRow-1}-${col}`) && wallNodesSet.has(`${endRow+1}-${col}`))) {\n            if (!wallNodesSet.has(`${startRow-1}-${col}`) && wallNodesSet.has(`${endRow+1}-${col}`)) {\n                openRowOverride = startRow;\n                override = true;\n                break;\n            } else if (wallNodesSet.has(`${startRow-1}-${col}`) && !wallNodesSet.has(`${endRow+1}-${col}`)) {\n                openRowOverride = endRow;\n                override = true;\n                break;\n            }\n            if (tries === 0) return;\n            col = getRandomInt(startCol+1, endCol-1);\n            tries--;\n        }\n        // const col = Math.floor((startCol + endCol) / 2);\n        let openRow = getRandomInt(startRow, endRow);\n        if (override) openRow = openRowOverride;\n        for (let row = startRow; row <= endRow; row++) {\n            if (row === openRow) continue;\n            const currentNode = grid[row][col];\n            if (currentNode.isStart || currentNode.isFinish) continue;\n            wallNodesInOrder.push(currentNode);\n            wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n        }\n        divisionHelper(grid, startRow, endRow, startCol, col-1, wallNodesInOrder, wallNodesSet);\n        divisionHelper(grid, startRow, endRow, col+1, endCol, wallNodesInOrder, wallNodesSet);\n    } else if (typeOfDivide === 'horizontal') {\n        let row = getRandomInt(startRow+1, endRow-1), tries = 10;\n        let override = false, openColOverride = -1;\n        while (!(wallNodesSet.has(`${row}-${startCol-1}`) && wallNodesSet.has(`${row}-${endCol+1}`))) {\n            if (!wallNodesSet.has(`${row}-${startCol-1}`) && wallNodesSet.has(`${row}-${endCol+1}`)) {\n                openColOverride = startCol;\n                override = true;\n                break;\n            } else if (wallNodesSet.has(`${row}-${startCol-1}`) && !wallNodesSet.has(`${row}-${endCol+1}`)) {\n                openColOverride = endCol;\n                override = true;\n            }\n            if (tries === 0) return;\n            row = getRandomInt(startRow+1, endRow-1);\n            tries--;\n        }\n        // const row = Math.floor((startRow + endRow) / 2);\n        let openCol = getRandomInt(startCol, endCol);\n        if (override) openCol = openColOverride;\n        for (let col = startCol; col <= endCol; col++) {\n            if (col === openCol) continue;\n            const currentNode = grid[row][col];\n            if (currentNode.isStart || currentNode.isFinish) continue;\n            wallNodesInOrder.push(currentNode);\n            wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n        }\n        divisionHelper(grid, startRow, row-1, startCol, endCol, wallNodesInOrder, wallNodesSet);\n        divisionHelper(grid, row+1, endRow, startCol, endCol, wallNodesInOrder, wallNodesSet);\n    }\n}\n\nfunction getRandomInt(min, max) {\n    let result = Math.floor(Math.random() * Math.floor(max - min)) + min;\n    if (max-1 === min) {\n        const flag = Math.random();\n        if (flag <= 0.5) return min;\n        if (flag > 0.5) return max;\n    }\n    return result;\n}\n\nexport default recursiveDivision;","function binaryTreeMaze(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n    // const newGrid = grid;\n    const wallNodesInOrder = [];\n\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[0].length; col++) {\n            const node = grid[row][col];\n            if (node.isStart || node.isFinish) continue;\n            wallNodesInOrder.push(node);\n        }\n    }\n    const nodesInOrder = [];\n\n    const startRow = 1;\n    const startCol = 1;\n    const endRow = grid.length-2;\n    const endCol = grid[0].length-2;\n\n    for (let row = 1; row <= endRow; row = row + 2) {\n        for (let col = 1; col <= endCol; col = col + 2) {\n            const currentNode = grid[row][col];\n            nodesInOrder.push(currentNode);\n            \n            const neighbours = [];\n            if (row > startRow) neighbours.push(grid[row-2][col]);\n            if (col > startCol) neighbours.push(grid[row][col-2]);\n\n            if (neighbours.length === 0) continue;\n\n            let randomIndex;\n            if (Math.random() < 0.5) {\n                randomIndex = 0 % neighbours.length;\n            } else {\n                randomIndex = 1 % neighbours.length;\n            }\n\n            nodesInOrder.push(connect(currentNode, neighbours[randomIndex], grid));\n        }\n    }\n\n    return [wallNodesInOrder, nodesInOrder];\n}\n\nfunction connect(currentNode, neighbourNode, grid) {\n    let row = Math.floor((currentNode.row + neighbourNode.row) / 2);\n    let col = Math.floor((currentNode.col + neighbourNode.col) / 2);\n    return grid[row][col];\n}\n\nexport default binaryTreeMaze;","function depthFirstSearchMaze(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n\n    const wallNodesInOrder = [];\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[0].length; col++) {\n            const node = grid[row][col];\n            if (node.isStart || node.isFinish) continue;\n            wallNodesInOrder.push(node);\n        }\n    }\n\n    const nodesInOrder = [];\n    const stack = [];\n    stack.push(startNode);\n\n    while (!!stack.length) {\n        const currentNode = stack.pop();\n\n        if (currentNode.isExplored) continue;\n\n        currentNode.isExplored = true;\n        nodesInOrder.push(currentNode);\n        if (!!currentNode.previousExploredNode) {\n            nodesInOrder.push(connect(currentNode, currentNode.previousExploredNode, grid));\n        }\n        getUnvisitedNeighboursInRandomOrder(currentNode, stack, grid);\n    }\n\n    return [wallNodesInOrder, nodesInOrder];\n}\n\nfunction getUnvisitedNeighboursInRandomOrder(node, stack, grid) {\n    const unvisitedNeighbours = [];\n    const row = node.row, col = node.col;\n\n    if (row > 2 && !grid[row-2][col].isExplored) unvisitedNeighbours.push(grid[row-2][col]);\n    if (col > 2 && !grid[row][col-2].isExplored) unvisitedNeighbours.push(grid[row][col-2]);\n    if (row < grid.length-3 && !grid[row+2][col].isExplored) unvisitedNeighbours.push(grid[row+2][col]);\n    if (col < grid[0].length-3 && !grid[row][col+2].isExplored) unvisitedNeighbours.push(grid[row][col+2]);\n\n    while (!!unvisitedNeighbours.length) {\n        const randomIndex = Math.floor(Math.random() * unvisitedNeighbours.length);\n        const randomNode = unvisitedNeighbours[randomIndex];\n        randomNode.previousExploredNode = node;\n        stack.push(randomNode);\n        unvisitedNeighbours.splice(randomIndex, 1);\n    }\n}\n\nfunction connect(currentNode, neighbourNode, grid) {\n    let row = Math.floor((currentNode.row + neighbourNode.row) / 2);\n    let col = Math.floor((currentNode.col + neighbourNode.col) / 2);\n    return grid[row][col];\n}\n\nexport default depthFirstSearchMaze;","import React, { useState, useReducer, useEffect } from \"react\";\nimport \"./PathFindingVisualizer.css\";\nimport PathFindingGrid from \"./PathFindingGrid/PathFindingGrid\";\nimport SideMenu from \"./SideMenu\";\nimport SmallScreenContainerText from \"./SmallScreenContainerText\";\nimport { Container, Grid } from \"semantic-ui-react\";\nimport bfs from \"../../algorithms/path-finding-algorithms/breath-first-search\";\nimport aStarSearch from \"../../algorithms/path-finding-algorithms/a-star-search-queue\";\nimport aStarSearchMinHeap from \"../../algorithms/path-finding-algorithms/a-star-search\";\nimport dfs from \"../../algorithms/path-finding-algorithms/depth-first-search\";\nimport recursiveDivision from \"../../algorithms/maze-generation-algorithms/recursive-division\";\nimport binaryTreeMaze from \"../../algorithms/maze-generation-algorithms/binary-tree-maze\";\nimport depthFirstSearchMaze from \"../../algorithms/maze-generation-algorithms/depth-first-search-maze\";\n\nconst START_NODE_ROW = 11;\nconst START_NODE_COL = 5;\nconst FINISH_NODE_ROW = 11;\nconst FINISH_NODE_COL = 45;\n\nexport default function PathFindingVisualizer() {\n  const [grid, setGrid] = useState(getInitialGrid());\n  const [algoString, setAlgoString] = useState(\"Breadth First Search\");\n  const [animateFlag, setAnimateFlag] = useState(false);\n  const [mazeFlag, setMazeFlag] = useState(false);\n  const [clearFlag, setClearFlag] = useState(true);\n  const [algorithm, dispatch] = useReducer(algoReducer, bfs);\n\n  useEffect(() => {\n    dispatch({ type: algoString });\n  }, [algoString]);\n\n  const visualizeAlgorithm = () => {\n    const copyOfGrid = grid;\n    const algoToVisualize = algorithm;\n    const startNode = copyOfGrid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = copyOfGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const [visitedNodesInOrder, nodesInShortestPathOrder] = algoToVisualize(\n      copyOfGrid,\n      startNode,\n      finishNode\n    );\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    setAnimateFlag(true);\n    setClearFlag(false);\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      } else {\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          // const newGrid = getNewGridWithVisitedClass(grid, node.row, node.col);\n          // setGrid(newGrid);\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }, 20 * i);\n      }\n    }\n  };\n\n  const animateShortestPath = nodesInShortestPathOrder => {\n    for (let j = 0; j < nodesInShortestPathOrder.length; j++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[j];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest\";\n      }, 50 * j);\n    }\n    setTimeout(() => {\n      setAnimateFlag(false);\n    }, 50 * nodesInShortestPathOrder.length);\n  };\n\n  const clearGrid = () => {\n    setGrid(getInitialGrid());\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (grid[row][col].isStart) {\n          document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n        } else if (grid[row][col].isFinish) {\n          document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n        } else {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    setClearFlag(true);\n    setMazeFlag(false);\n    setAnimateFlag(false);\n  };\n\n  const handleSelection = newAlgoString => {\n    setAlgoString(newAlgoString);\n  };\n\n  const handleWallGeneration = wallString => {\n    let wallAlgo = () => {};\n    let startWithWalls;\n    setMazeFlag(true);\n    if (wallString === 'Default'){\n      return;\n    } else if (wallString === 'Recursive Division') {\n      wallAlgo = recursiveDivision;\n      startWithWalls = false;\n    } else if (wallString === 'Binary Tree Maze') {\n      wallAlgo = binaryTreeMaze;\n      startWithWalls = true;\n    } else if (wallString === 'Depth First Search Maze') {\n      wallAlgo = depthFirstSearchMaze;\n      startWithWalls = true;\n    }\n\n    const copyOfGrid = grid;\n    const startNode = copyOfGrid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = copyOfGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    if (!startWithWalls) {\n      const [newGrid, wallNodesInOrder] = wallAlgo(grid, startNode, finishNode);\n      animateWallAlgo(wallNodesInOrder);\n    } else {\n      const [wallNodesInOrder, nodesInOrder] = wallAlgo(grid, startNode, finishNode);\n      animateFullWalls();\n      setTimeout(() => {animateNodeAlgo(nodesInOrder)}, 20 * Math.ceil(wallNodesInOrder.length / 2));\n    }\n  }\n\n  const animateNodeAlgo = (nodesInOrder) => {\n    for (let i = 0; i < nodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInOrder[i];\n        const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n        setGrid(newGrid);\n        if (!(node.isStart || node.isFinish)) {\n          // document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-intermediate\";\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node\";\n        };\n      }, 50 * i);\n    }\n    setTimeout(() => {\n      setAnimateFlag(false);\n    }, 50 * nodesInOrder.length);\n  }\n\n  const animateFullWalls = () => {\n    setAnimateFlag(true);\n    let i = 0, j = 0, isIncreasing = true, count = 0;\n    const lastRow = grid.length, lastCol = grid[0].length;\n    const nodesInOrder = [];\n    while (i < lastRow) {\n      while (0 <= j && j < lastCol) {\n        const node = grid[i][j];\n        nodesInOrder.push(node);\n        if (isIncreasing) {\n          j++;\n        } else {\n          j--;\n        }\n      }\n      if (isIncreasing) {\n        j--;\n      } else {\n        j++;\n      }\n      isIncreasing = !isIncreasing;\n      i++;\n    }\n    \n    for (let i = 0; i <= nodesInOrder.length - i - 1; i++) {\n      if (i === nodesInOrder.length - i - 1) {\n        setTimeout(() => {\n          const node = nodesInOrder[i];\n          const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n          setGrid(newGrid);\n          if (!(node.isStart || node.isFinish)) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\";\n          };\n        }, 20 * i);\n      } else {\n        setTimeout(() => {\n          const node1 = nodesInOrder[i];\n          const node2 = nodesInOrder[nodesInOrder.length - i - 1];\n          const newGrid1 = getNewGridWithWallToggled(grid, node1.row, node1.col);\n          setGrid(newGrid1);\n          const newGrid2 = getNewGridWithWallToggled(grid, node2.row, node2.col);\n          setGrid(newGrid2);\n  \n          if (!(node1.isStart || node1.isFinish)) {\n            document.getElementById(`node-${node1.row}-${node1.col}`).className = \"node node-wall\";\n          };\n          if (!(node2.isStart || node2.isFinish)) {\n            document.getElementById(`node-${node2.row}-${node2.col}`).className = \"node node-wall\";\n          }\n        }, 20 * i);\n      }\n    }\n  }\n\n  const animateWallAlgo = (wallNodesInOrder) => {\n    setAnimateFlag(true);\n    for (let i = 0; i < wallNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = wallNodesInOrder[i];\n        const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n        setGrid(newGrid);\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-wall\";\n      }, 20 * i);\n    }\n    setTimeout(() => {\n      setAnimateFlag(false);\n    }, 20 * wallNodesInOrder.length);\n  }\n\n  return (\n    <div>\n      <Grid verticalAlign=\"middle\" >\n        <Grid.Column width={3} floated=\"left\">\n          <Container fluid className='sideMenuWrapper'>\n            <SideMenu\n              handleSelection={handleSelection}\n              visualizeAlgorithm={visualizeAlgorithm}\n              clearGrid={clearGrid}\n              handleWallGeneration={handleWallGeneration}\n              animateFlag={animateFlag}\n              mazeFlag={mazeFlag}\n              clearFlag={clearFlag}\n            />\n          </Container>\n        </Grid.Column>\n        <Grid.Column width={13}>\n          <PathFindingGrid\n            algoString={algoString}\n            grid={grid}\n            setGrid={setGrid}\n            getNewGridWithWallToggled={getNewGridWithWallToggled}\n          />\n        </Grid.Column>\n        {/* <Grid.Column className=\"segment centered\" only=\"mobile tablet\">\n          <SmallScreenContainerText />\n        </Grid.Column> */}\n      </Grid>\n    </div>\n  );\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row <= 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col <= 50; col++) {\n      const currentNode = createNode(col, row);\n      currentRow.push(currentNode);\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    gScore: Infinity,\n    fScore: Infinity,\n    isVisited: false,\n    isWall: false,\n    visitedClass: false,\n    previousNode: null,\n    isExplored: false,\n    previousExploredNode: false\n  };\n};\n\nconst algoReducer = (state, action) => {\n  switch (action.type) {\n    case \"Breadth First Search\":\n      return bfs;\n    case \"A-star Search\":\n      return aStarSearch;\n    case \"A-star Search Min Heap\":\n      return aStarSearchMinHeap\n    case \"Depth First Search\":\n      return dfs;\n    default:\n      return bfs;\n  }\n};\n\nconst getNewGridWithVisitedClass = (grid, row, col) => {\n  const newGrid = grid;\n  const node = newGrid[row][col];\n  if (node.isStart || node.isFinish) return grid;\n  const newNode = {\n    ...node,\n    visitedClass: true\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid;\n  const node = newGrid[row][col];\n  if (node.isStart || node.isFinish) return grid;\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React from \"react\";\nimport {\n  Container,\n  Image,\n  Menu,\n} from \"semantic-ui-react\";\n\nfunction NavigationBar(props) {\n  // const { algoString, handleSelection } = props;\n\n  return (\n    <div>\n      <Menu fixed=\"top\" inverted>\n        <Container>\n          <Menu.Item as=\"a\" href=\"https://www.github.com/samuelwongsy\" header>\n            <Image\n              size=\"mini\"\n              src={require(\"../images/snowflake.svg\")}\n              style={{ marginRight: \"1.5em\" }}\n            />\n            Samuel Wong\n          </Menu.Item>\n          <Menu.Item as=\"a\" href=\"/algo-visualizer\">\n            Algorithm Visualizer\n          </Menu.Item>\n\n          {/* <Dropdown item simple text=\"Pathfinding Visualizer\">\n            <Dropdown.Menu>\n              <Dropdown.Header>Algorithms</Dropdown.Header>\n              <Dropdown.Item\n                value=\"bfs\"\n                onClick={(e, d) => handleSelection(d.value)}\n              >\n                Breadth First Search\n              </Dropdown.Item>\n              <Dropdown.Item\n                value=\"a-star\"\n                onClick={(e, d) => handleSelection(d.value)}\n              >\n                A* Search\n              </Dropdown.Item>\n            </Dropdown.Menu>\n          </Dropdown>\n          <Menu.Item>Visualizing: {algoString}</Menu.Item> */}\n        </Container>\n      </Menu>\n    </div>\n  );\n}\n\nexport default NavigationBar;\n","import React from \"react\";\nimport PathFindingVisualizer from \"./PathFindingVisualizer/PathFindingVisualizer\";\nimport NavigationBar from \"./NavigationBar\";\nimport SmallScreenContainerText from \"./PathFindingVisualizer/SmallScreenContainerText\";\nimport { Container, Grid } from \"semantic-ui-react\";\n\nexport default function HomePage() {\n  return (\n    <div>\n      <Grid divided='vertically' style={{height: '1000px', backgroundColor: \"rgb(32,32,32)\"}}>\n        <Grid.Row style={{height: '7%'}}>\n          <NavigationBar />\n        </Grid.Row>\n        <Grid.Row style={{height: '100%', backgroundColor: \"rgb(32,32,32)\"}}>\n          <PathFindingVisualizer />\n        </Grid.Row>\n      </Grid>\n    </div>\n  );\n}\n","import React from \"react\";\nimport HomePage from \"./components/HomePage\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <HomePage />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport \"semantic-ui-css/semantic.min.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}