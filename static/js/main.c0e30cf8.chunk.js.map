{"version":3,"sources":["images/snowflake.svg","components/PathFindingVisualizer/PathFindingGrid/Node/Node.jsx","components/PathFindingVisualizer/PathFindingGrid/PathFindingGrid.jsx","components/PathFindingVisualizer/SideMenu.jsx","algorithms/path-finding-algorithms/breath-first-search.js","algorithms/path-finding-algorithms/a-star-search-queue.js","algorithms/path-finding-algorithms/a-star-search.js","algorithms/data-structures/MinHeap.js","algorithms/path-finding-algorithms/depth-first-search.js","algorithms/maze-generation-algorithms/recursive-division.js","algorithms/maze-generation-algorithms/binary-tree-maze.js","algorithms/maze-generation-algorithms/depth-first-search-maze.js","algorithms/maze-generation-algorithms/randomized-prims-algorithm.js","components/PathFindingVisualizer/PathFindingVisualizer.jsx","components/NavigationBar.jsx","components/HomePage.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","props","row","col","isFinish","isStart","isWall","isVisited","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","PathFindingGrid","useState","mouseDown","setMouseDown","grid","setGrid","getNewGridWithWallToggled","handleClick","newGrid","map","rowIndex","key","node","colIndex","visitedClass","handleMouseDown","handleMouseEnter","onClick","SideMenu","state","activeItem","activeWall","handleItemClick","e","name","setState","handleSelection","handleWallAlgoClick","mazeFlag","clearFlag","handleWallGeneration","clearGrid","this","visualizeAlgorithm","animateFlag","Menu","fluid","inverted","vertical","size","Item","active","Button","secondary","icon","labelPosition","disabled","Icon","Component","updateUnvisitedNeighbours","queue","unvisitedNeighbours","neighbours","push","length","filter","getUnvisitedNeighbours","neighbour","previousNode","bfs","FINISH_NODE_ROW","FINISH_NODE_COL","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","currentNode","shift","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","getHeuristics","Math","abs","updateNeighbours","getNeighbours","tentativeGScore","gScore","distance","includes","sort","a","b","aStarSearch","openNodes","MinHeap","array","heap","buildHeap","currentIdx","floor","siftDown","endIdx","childOneIdx","childTwoIdx","idxToSwap","swap","parentIdx","valueToRemove","pop","value","siftUp","i","j","temp","minHeap","insert","remove","stack","dfs","getRandomInt","min","max","result","random","flag","recursiveDivision","wallNodesInOrder","wallNodesSet","Set","endRow","endCol","add","divisionHelper","startRow","startCol","typeOfDivide","height","width","tries","override","openRowOverride","has","openRow","openColOverride","openCol","connect","neighbourNode","binaryTreeMaze","nodesInOrder","randomIndex","getUnvisitedNeighboursInRandomOrder","isExplored","randomNode","previousExploredNode","splice","depthFirstSearchMaze","getConnectedNeighbours","connectedNeighbours","isConnected","getUnconnectedNeighbours","path","pathSet","unconnectedNeighbours","node1","node2","randomizedPrimsAlgorithmMaze","randIdx","delete","connectedNode","PathFindingVisualizer","getInitialGrid","algoString","setAlgoString","setAnimateFlag","setMazeFlag","setClearFlag","useReducer","algoReducer","algorithm","dispatch","useEffect","type","animateAlgorithm","setTimeout","animateShortestPath","document","getElementById","animateNodeAlgo","animateFullWalls","isIncreasing","lastRow","lastCol","newGrid1","newGrid2","animateWallAlgo","Grid","verticalAlign","Column","floated","Container","newAlgoString","copyOfGrid","wallString","startWithWalls","wallAlgo","ceil","currentRow","createNode","Infinity","fScore","action","aStarSearchMinHeap","newNode","NavigationBar","fixed","as","href","header","Image","src","require","style","marginRight","HomePage","divided","backgroundColor","Row","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.c0e30cf8.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/snowflake.6114f6e9.svg\";","import React, { useState } from \"react\";\nimport \"./Node.css\";\n\nfunction Node(props) {\n  const {\n    row,\n    col,\n    isFinish,\n    isStart,\n    isWall,\n    isVisited,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n  } = props;\n\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : isVisited\n    ? \"node-visited\"\n    : \"\";\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseUp={() => onMouseUp()}\n    ></div>\n  );\n}\n\nexport default Node;\n","import React, { useState, useEffect } from \"react\";\nimport Node from \"./Node/Node\";\nimport \"./PathFindingGrid.css\";\n\nfunction PathFindingGrid(props) {\n  const [mouseDown, setMouseDown] = useState(false);\n  const { grid, setGrid, getNewGridWithWallToggled } = props;\n\n  // useEffect(() => {\n  //   for (let row = 0; row < grid.length; row++) {\n  //     for (let col = 0; col < grid[0].length; col++) {\n  //       document.getElementById(`node-${row}-${col}`).className = \"node\";\n  //     }\n  //   }\n  // }, [grid]);\n\n  const handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setMouseDown(true);\n    setGrid(newGrid);\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseDown) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseDown(false);\n  };\n\n  const handleClick = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  return (\n    <div>\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => {\n          return (\n            <div key={rowIndex} className=\"row\">\n              {row.map((node, colIndex) => (\n                <Node\n                  key={[node.col, node.row]}\n                  isStart={node.isStart}\n                  isFinish={node.isFinish}\n                  isWall={node.isWall}\n                  isVisited={node.visitedClass}\n                  // mousePressed={mouseDown}\n                  onMouseDown={(row, col) => handleMouseDown(row, col)}\n                  onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                  onMouseUp={() => handleMouseUp()}\n                  onClick={handleClick}\n                  row={node.row}\n                  col={node.col}\n                />\n              ))}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\n\nexport default PathFindingGrid;\n","import React, { Component } from \"react\";\nimport { Menu, Button, Icon } from \"semantic-ui-react\";\n\nexport default class SideMenu extends Component {\n  state = { \n    activeItem: \"Breadth First Search\",\n    activeWall: \"Default\"\n  };\n\n  handleItemClick = (e, { name }) => {\n    this.setState({ activeItem: name });\n    this.props.handleSelection(name);\n  };\n\n  handleWallAlgoClick = (e, { name }) => {\n    if (this.props.mazeFlag || !this.props.clearFlag) return;\n    this.setState({ activeWall: name });\n    this.props.handleWallGeneration(name);\n  }\n\n  clearGrid = (e) => {\n    this.setState({ activeWall: \"Default\" });\n    this.props.clearGrid();\n  }\n\n  render() {\n    const { activeItem, activeWall } = this.state;\n    const { visualizeAlgorithm, clearGrid, animateFlag, clearFlag } = this.props;\n\n    return (\n      <Menu fluid inverted vertical size=\"large\">\n        <Menu.Item>\n          Algorithms\n          <Menu.Menu>\n            <Menu.Item\n              name=\"Breadth First Search\"\n              active={activeItem === \"Breadth First Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"Depth First Search\"\n              active={activeItem === \"Depth First Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"A-star Search\"\n              active={activeItem === \"A-star Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"A-star Search Min Heap\"\n              active={activeItem === \"A-star Search Min Heap\"}\n              onClick={this.handleItemClick}\n            />\n          </Menu.Menu>\n        </Menu.Item>\n\n        <Menu.Item>\n          Wall Generation\n          <Menu.Menu>\n            <Menu.Item \n              name=\"Recursive Division\"\n              active={activeWall === \"Recursive Division\"}\n              onClick={this.handleWallAlgoClick}\n            />\n            <Menu.Item \n              name=\"Binary Tree Maze\"\n              active={activeWall === \"Binary Tree Maze\"}\n              onClick={this.handleWallAlgoClick}\n            />\n            <Menu.Item \n              name=\"Depth First Search Maze\"\n              active={activeWall === \"Depth First Search Maze\"}\n              onClick={this.handleWallAlgoClick}\n            />\n            <Menu.Item \n              name=\"Randomized Prim's Algorithm\"\n              active={activeWall === \"Randomized Prim's Algorithm\"}\n              onClick={this.handleWallAlgoClick}\n            />\n          </Menu.Menu>\n        </Menu.Item>\n        \n        <Menu.Item>\n          <Button\n            fluid\n            secondary\n            icon\n            labelPosition=\"right\"\n            onClick={visualizeAlgorithm}\n            disabled={animateFlag || (!animateFlag && !clearFlag)}\n          >\n            Visualize\n            <Icon name=\"caret square right\" />\n          </Button>\n        </Menu.Item>\n        <Menu.Item>\n          <Button\n            fluid\n            secondary\n            icon\n            labelPosition=\"right\"\n            onClick={this.clearGrid}\n            disabled={animateFlag}\n          >\n            Clear\n            <Icon name=\"redo alternate\" />\n          </Button>\n        </Menu.Item>\n      </Menu>\n    );\n  }\n}\n","// Breath-first search using a queue\n\nfunction bfs(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = []; // queue\n  unvisitedNodes.push(startNode);\n\n  while (!!unvisitedNodes.length) {\n    const currentNode = unvisitedNodes.shift();\n\n    if (currentNode.isWall) continue;\n\n    if (currentNode.isVisited) continue;\n\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === finishNode) break;\n\n    updateUnvisitedNeighbours(currentNode, unvisitedNodes, grid);\n  }\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n  // console.log(visitedNodesInOrder);\n\n  return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction updateUnvisitedNeighbours(node, queue, grid) {\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of unvisitedNeighbours) {\n    neighbour.previousNode = node;\n    queue.push(neighbour);\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const {\n    col,\n    row\n  } = node;\n\n  const neighbours = [];\n\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n  return neighbours.filter(node => !node.isVisited);\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n  if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nexport default bfs;","// a-star search using manhatten distance heuristics\n// not using visited because a-star search allows you to reach a visited node with\n// a lower distance\n\nlet FINISH_NODE_ROW;\nlet FINISH_NODE_COL;\n\nfunction aStarSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n\n  FINISH_NODE_ROW = finishNode.row;\n  FINISH_NODE_COL = finishNode.col;\n\n  const visitedNodesInOrder = [];\n  const openNodes = [];\n  openNodes.push(startNode);\n  while (!!openNodes.length) {\n    const currentNode = openNodes.shift();\n\n    if (currentNode === startNode) {\n      currentNode.gScore = 0;\n      currentNode.distance = getHeuristics(currentNode);\n    }\n\n    if (currentNode.isWall) continue;\n\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === finishNode) {\n      finishNode.isVisited = true;\n      break;\n    }\n\n    updateNeighbours(currentNode, openNodes, grid);\n  }\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n  // console.log(visitedNodesInOrder);\n\n  return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction getHeuristics(node) {\n  const distance = Math.abs(node.row - FINISH_NODE_ROW) + Math.abs(node.col - FINISH_NODE_COL);\n  return distance\n}\n\nfunction updateNeighbours(node, queue, grid) {\n  const neighbours = getNeighbours(node, grid);\n\n  for (const neighbour of neighbours) {\n    const tentativeGScore = node.gScore + 1;\n    if (tentativeGScore < neighbour.gScore) {\n      neighbour.previousNode = node;\n      neighbour.gScore = tentativeGScore;\n      neighbour.distance = neighbour.gScore + getHeuristics(neighbour);\n      if (!queue.includes(neighbour)) queue.push(neighbour);\n    }\n  }\n  queue.sort((a, b) => a.distance - b.distance);\n}\n\nfunction getNeighbours(node, grid) {\n  const {\n    col,\n    row\n  } = node;\n\n  const neighbours = [];\n\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n  return neighbours;\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n  if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nexport default aStarSearch;","import MinHeap from '../data-structures/MinHeap';\n// a-star search using manhatten distance heuristics\n// not using visited because a-star search allows you to reach a visited node with\n// a lower distance\n\nlet FINISH_NODE_ROW;\nlet FINISH_NODE_COL;\n\nfunction aStarSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n\n  FINISH_NODE_ROW = finishNode.row;\n  FINISH_NODE_COL = finishNode.col;\n\n  const visitedNodesInOrder = [];\n  const openNodes = new MinHeap([]);\n  openNodes.insert(startNode);\n  while (!!openNodes.heap.length) {\n    // console.log(openNodes.heap);\n    const currentNode = openNodes.remove();\n\n    if (currentNode === startNode) {\n      currentNode.gScore = 0;\n      currentNode.distance = getHeuristics(currentNode);\n    }\n\n    if (currentNode.isWall) continue;\n\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === finishNode) {\n      finishNode.isVisited = true;\n      break;\n    }\n\n    updateNeighbours(currentNode, openNodes, grid);\n  }\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n  // console.log(visitedNodesInOrder);\n\n  return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction getHeuristics(node) {\n  const distance = Math.abs(node.row - FINISH_NODE_ROW) +\n    Math.abs(node.col - FINISH_NODE_COL);\n\n  return distance\n}\n\nfunction updateNeighbours(node, minHeap, grid) {\n  const neighbours = getNeighbours(node, grid);\n\n  for (const neighbour of neighbours) {\n    const tentativeGScore = node.gScore + 1;\n    if (tentativeGScore < neighbour.gScore) {\n      neighbour.previousNode = node;\n      neighbour.gScore = tentativeGScore;\n      neighbour.distance = neighbour.gScore + getHeuristics(neighbour);\n      if (!minHeap.heap.includes(neighbour)) minHeap.insert(neighbour);\n    }\n  }\n}\n\nfunction getNeighbours(node, grid) {\n  const {\n    col,\n    row\n  } = node;\n\n  const neighbours = [];\n\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n  return neighbours;\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n  if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nexport default aStarSearch;","class MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx].distance < heap[childOneIdx].distance) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].distance < heap[currentIdx].distance) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx].distance < heap[parentIdx].distance) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.heap[0];\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\n// Do not edit the line below.\nexport default MinHeap;","// Depth-first search using a stack\n\nfunction dfs(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = []; //stack\n  unvisitedNodes.push(startNode);\n\n  while (!!unvisitedNodes.length) {\n    const currentNode = unvisitedNodes.pop();\n\n    if (currentNode.isWall) continue;\n\n    if (currentNode.isVisited) continue;\n\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === finishNode) break;\n\n    updateUnvisitedNeighbours(currentNode, unvisitedNodes, grid);\n  }\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n  return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction updateUnvisitedNeighbours(node, stack, grid) {\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of unvisitedNeighbours) {\n    neighbour.previousNode = node;\n    stack.push(neighbour);\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const {\n    col,\n    row\n  } = node;\n\n  const neighbours = [];\n\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n  return neighbours.filter(node => !node.isVisited);\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n  if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nexport default dfs;","function recursiveDivision(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [grid, []];\n  }\n  const newGrid = grid;\n  const wallNodesInOrder = [];\n  const wallNodesSet = new Set();\n  \n  const startRow = 0;\n  const startCol = 0;\n  const endRow = grid.length-1;\n  const endCol = grid[0].length-1;\n  // inital boundary\n  for (let col = 0; col < grid[0].length; col++) {\n    const currentNode = grid[0][col];\n    wallNodesInOrder.push(currentNode);\n    wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n  }\n\n  for (let row = 1; row < grid.length-1; row++) {\n    const currentNode = grid[row][endCol];\n    wallNodesInOrder.push(currentNode);\n    wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n  }\n\n  for (let col = endCol; col >= 0; col--) {\n    const currentNode = grid[endRow][col];\n    wallNodesInOrder.push(currentNode);\n    wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n  }\n\n  for (let row = endRow - 1; row > 0; row--) {\n    const currentNode = grid[row][startCol];\n    wallNodesInOrder.push(currentNode);\n    wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n  }\n\n  divisionHelper(newGrid, startRow+1, endRow-1, startCol+1, endCol-1, wallNodesInOrder, wallNodesSet);\n\n  return [newGrid, wallNodesInOrder]\n}\n\nfunction divisionHelper(grid, startRow, endRow, startCol, endCol, wallNodesInOrder, wallNodesSet) {\n  // if (startRow >= endRow - 2) return;\n  // if (startCol >= endCol - 2) return;\n\n  const height = endRow - startRow;\n  const width = endCol - startCol;\n\n  if (height <= 1 && width <= 1) return;\n  \n  let typeOfDivide;\n  if (width >= height) {\n    typeOfDivide = 'vertical';\n  } else {\n    typeOfDivide = 'horizontal';\n  }\n\n  if (height === 3 && typeOfDivide === 'vertical') {\n    typeOfDivide = 'horizontal';\n  } else if (width === 3 && typeOfDivide === 'horizontal') {\n    typeOfDivide = 'vertical';\n  }\n\n  if (typeOfDivide === 'vertical') {\n    let col = getRandomInt(startCol+1, endCol-1), tries = 10;\n    let override = false, openRowOverride = -1;\n    while (!(wallNodesSet.has(`${startRow-1}-${col}`) && wallNodesSet.has(`${endRow+1}-${col}`))) {\n      if (!wallNodesSet.has(`${startRow-1}-${col}`) && wallNodesSet.has(`${endRow+1}-${col}`)) {\n        openRowOverride = startRow;\n        override = true;\n        break;\n      } else if (wallNodesSet.has(`${startRow-1}-${col}`) && !wallNodesSet.has(`${endRow+1}-${col}`)) {\n        openRowOverride = endRow;\n        override = true;\n        break;\n      }\n      if (tries === 0) return;\n      col = getRandomInt(startCol+1, endCol-1);\n      tries--;\n    }\n    // const col = Math.floor((startCol + endCol) / 2);\n    let openRow = getRandomInt(startRow, endRow);\n    if (override) openRow = openRowOverride;\n    for (let row = startRow; row <= endRow; row++) {\n      if (row === openRow) continue;\n      const currentNode = grid[row][col];\n      if (currentNode.isStart || currentNode.isFinish) continue;\n      wallNodesInOrder.push(currentNode);\n      wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n    divisionHelper(grid, startRow, endRow, startCol, col-1, wallNodesInOrder, wallNodesSet);\n    divisionHelper(grid, startRow, endRow, col+1, endCol, wallNodesInOrder, wallNodesSet);\n  } else if (typeOfDivide === 'horizontal') {\n    let row = getRandomInt(startRow+1, endRow-1), tries = 10;\n    let override = false, openColOverride = -1;\n    while (!(wallNodesSet.has(`${row}-${startCol-1}`) && wallNodesSet.has(`${row}-${endCol+1}`))) {\n      if (!wallNodesSet.has(`${row}-${startCol-1}`) && wallNodesSet.has(`${row}-${endCol+1}`)) {\n        openColOverride = startCol;\n        override = true;\n        break;\n      } else if (wallNodesSet.has(`${row}-${startCol-1}`) && !wallNodesSet.has(`${row}-${endCol+1}`)) {\n        openColOverride = endCol;\n        override = true;\n      }\n      if (tries === 0) return;\n      row = getRandomInt(startRow+1, endRow-1);\n      tries--;\n    }\n    // const row = Math.floor((startRow + endRow) / 2);\n    let openCol = getRandomInt(startCol, endCol);\n    if (override) openCol = openColOverride;\n    for (let col = startCol; col <= endCol; col++) {\n      if (col === openCol) continue;\n      const currentNode = grid[row][col];\n      if (currentNode.isStart || currentNode.isFinish) continue;\n      wallNodesInOrder.push(currentNode);\n      wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n    divisionHelper(grid, startRow, row-1, startCol, endCol, wallNodesInOrder, wallNodesSet);\n    divisionHelper(grid, row+1, endRow, startCol, endCol, wallNodesInOrder, wallNodesSet);\n  }\n}\n\nfunction getRandomInt(min, max) {\n  let result = Math.floor(Math.random() * Math.floor(max - min)) + min;\n  if (max-1 === min) {\n    const flag = Math.random();\n    if (flag <= 0.5) return min;\n    if (flag > 0.5) return max;\n  }\n  return result;\n}\n\nexport default recursiveDivision;","function binaryTreeMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n  // const newGrid = grid;\n  const wallNodesInOrder = [];\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      const node = grid[row][col];\n      if (node.isStart || node.isFinish) continue;\n      wallNodesInOrder.push(node);\n    }\n  }\n  const nodesInOrder = [];\n\n  const startRow = 1;\n  const startCol = 1;\n  const endRow = grid.length-2;\n  const endCol = grid[0].length-2;\n\n  for (let row = 1; row <= endRow; row = row + 2) {\n    for (let col = 1; col <= endCol; col = col + 2) {\n      const currentNode = grid[row][col];\n      nodesInOrder.push(currentNode);\n      \n      const neighbours = [];\n      if (row > startRow) neighbours.push(grid[row-2][col]);\n      if (col > startCol) neighbours.push(grid[row][col-2]);\n\n      if (neighbours.length === 0) continue;\n\n      let randomIndex;\n      if (Math.random() < 0.5) {\n        randomIndex = 0 % neighbours.length;\n      } else {\n        randomIndex = 1 % neighbours.length;\n      }\n\n      nodesInOrder.push(connect(currentNode, neighbours[randomIndex], grid));\n    }\n  }\n\n  return [wallNodesInOrder, nodesInOrder];\n}\n\nfunction connect(currentNode, neighbourNode, grid) {\n  let row = Math.floor((currentNode.row + neighbourNode.row) / 2);\n  let col = Math.floor((currentNode.col + neighbourNode.col) / 2);\n  return grid[row][col];\n}\n\nexport default binaryTreeMaze;","function depthFirstSearchMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n\n  const wallNodesInOrder = [];\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      const node = grid[row][col];\n      if (node.isStart || node.isFinish) continue;\n      wallNodesInOrder.push(node);\n    }\n  }\n\n  const nodesInOrder = [];\n  const stack = [];\n  stack.push(startNode);\n\n  while (!!stack.length) {\n    const currentNode = stack.pop();\n\n    if (currentNode.isExplored) continue;\n\n    currentNode.isExplored = true;\n    nodesInOrder.push(currentNode);\n    if (!!currentNode.previousExploredNode) {\n      nodesInOrder.push(connect(currentNode, currentNode.previousExploredNode, grid));\n    }\n    getUnvisitedNeighboursInRandomOrder(currentNode, stack, grid);\n  }\n\n  return [wallNodesInOrder, nodesInOrder];\n}\n\nfunction getUnvisitedNeighboursInRandomOrder(node, stack, grid) {\n  const unvisitedNeighbours = [];\n  const row = node.row, col = node.col;\n\n  if (row > 2 && !grid[row-2][col].isExplored) unvisitedNeighbours.push(grid[row-2][col]);\n  if (col > 2 && !grid[row][col-2].isExplored) unvisitedNeighbours.push(grid[row][col-2]);\n  if (row < grid.length-3 && !grid[row+2][col].isExplored) unvisitedNeighbours.push(grid[row+2][col]);\n  if (col < grid[0].length-3 && !grid[row][col+2].isExplored) unvisitedNeighbours.push(grid[row][col+2]);\n\n  while (!!unvisitedNeighbours.length) {\n    const randomIndex = Math.floor(Math.random() * unvisitedNeighbours.length);\n    const randomNode = unvisitedNeighbours[randomIndex];\n    randomNode.previousExploredNode = node;\n    stack.push(randomNode);\n    unvisitedNeighbours.splice(randomIndex, 1);\n  }\n}\n\nfunction connect(currentNode, neighbourNode, grid) {\n  let row = Math.floor((currentNode.row + neighbourNode.row) / 2);\n  let col = Math.floor((currentNode.col + neighbourNode.col) / 2);\n  return grid[row][col];\n}\n\nexport default depthFirstSearchMaze;","function randomizedPrimsAlgorithmMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n  \n  const wallNodesInOrder = [];\n  for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n          const node = grid[row][col];\n          if (node.isStart || node.isFinish) continue;\n          wallNodesInOrder.push(node);\n      }\n  }\n\n  const nodesInOrder = [];\n  const path = [];\n  const pathSet = new Set();\n  path.push(startNode);\n  pathSet.add(`${startNode.row}-${startNode.col}`);\n\n  while (!!pathSet.size) {\n    const randIdx = Math.floor(Math.random()*path.length);\n    const currentNode = path[randIdx];\n    path.splice(randIdx, 1);\n    pathSet.delete(`${currentNode.row}-${currentNode.col}`);\n    if (currentNode.isConnected) continue;\n    currentNode.isConnected = true;\n    nodesInOrder.push(currentNode);\n\n    const neighbours = getConnectedNeighbours(grid, currentNode);\n    if (!!neighbours.length) {\n      const connectedNode = neighbours[Math.floor(Math.random()*neighbours.length)];\n      nodesInOrder.push(connect(connectedNode, currentNode, grid));\n    }\n\n    getUnconnectedNeighbours(grid, currentNode, path, pathSet);\n  }\n  return [wallNodesInOrder, nodesInOrder];\n}\n\nfunction getConnectedNeighbours(grid, node) {\n  const connectedNeighbours = [];\n  const row = node.row, col = node.col;\n  if (row > 2 && grid[row-2][col].isConnected) connectedNeighbours.push(grid[row-2][col]);\n  if (col > 2 && grid[row][col-2].isConnected) connectedNeighbours.push(grid[row][col-2]);\n  if (row < grid.length-3 && grid[row+2][col].isConnected) connectedNeighbours.push(grid[row+2][col]);\n  if (col < grid[0].length-3 && grid[row][col+2].isConnected) connectedNeighbours.push(grid[row][col+2]);\n\n  return connectedNeighbours;\n}\n\nfunction getUnconnectedNeighbours(grid, node, path, pathSet) {\n  const unconnectedNeighbours = [];\n  const row = node.row, col = node.col;\n  if (row > 2 && !grid[row-2][col].isConnected) unconnectedNeighbours.push(grid[row-2][col]);\n  if (col > 2 && !grid[row][col-2].isConnected) unconnectedNeighbours.push(grid[row][col-2]);\n  if (row < grid.length-3 && !grid[row+2][col].isConnected) unconnectedNeighbours.push(grid[row+2][col]);\n  if (col < grid[0].length-3 && !grid[row][col+2].isConnected) unconnectedNeighbours.push(grid[row][col+2]);\n\n  for (let i = 0; i < unconnectedNeighbours.length; i++){\n    const neighbour = unconnectedNeighbours[i];\n    path.push(neighbour);\n    pathSet.add(`${neighbour.row}-${neighbour.col}`);\n  }\n}\n\nfunction connect(node1, node2, grid) {\n  return grid[Math.floor(((node1.row+node2.row)/2))][Math.floor(((node1.col+node2.col)/2))]\n}\n\nexport default randomizedPrimsAlgorithmMaze;","import React, { useState, useReducer, useEffect } from \"react\";\nimport \"./PathFindingVisualizer.css\";\nimport PathFindingGrid from \"./PathFindingGrid/PathFindingGrid\";\nimport SideMenu from \"./SideMenu\";\nimport SmallScreenContainerText from \"./SmallScreenContainerText\";\nimport { Container, Grid } from \"semantic-ui-react\";\nimport bfs from \"../../algorithms/path-finding-algorithms/breath-first-search\";\nimport aStarSearch from \"../../algorithms/path-finding-algorithms/a-star-search-queue\";\nimport aStarSearchMinHeap from \"../../algorithms/path-finding-algorithms/a-star-search\";\nimport dfs from \"../../algorithms/path-finding-algorithms/depth-first-search\";\nimport recursiveDivision from \"../../algorithms/maze-generation-algorithms/recursive-division\";\nimport binaryTreeMaze from \"../../algorithms/maze-generation-algorithms/binary-tree-maze\";\nimport depthFirstSearchMaze from \"../../algorithms/maze-generation-algorithms/depth-first-search-maze\";\nimport randomizedPrimsAlgorithmMaze from \"../../algorithms/maze-generation-algorithms/randomized-prims-algorithm\";\n\nconst START_NODE_ROW = 11;\nconst START_NODE_COL = 5;\nconst FINISH_NODE_ROW = 11;\nconst FINISH_NODE_COL = 45;\n\nexport default function PathFindingVisualizer() {\n  const [grid, setGrid] = useState(getInitialGrid());\n  const [algoString, setAlgoString] = useState(\"Breadth First Search\");\n  const [animateFlag, setAnimateFlag] = useState(false);\n  const [mazeFlag, setMazeFlag] = useState(false);\n  const [clearFlag, setClearFlag] = useState(true);\n  const [algorithm, dispatch] = useReducer(algoReducer, bfs);\n\n  useEffect(() => {\n    dispatch({ type: algoString });\n  }, [algoString]);\n\n  const visualizeAlgorithm = () => {\n    const copyOfGrid = grid;\n    const algoToVisualize = algorithm;\n    const startNode = copyOfGrid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = copyOfGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const [visitedNodesInOrder, nodesInShortestPathOrder] = algoToVisualize(\n      copyOfGrid,\n      startNode,\n      finishNode\n    );\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    setAnimateFlag(true);\n    setClearFlag(false);\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      } else {\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          // const newGrid = getNewGridWithVisitedClass(grid, node.row, node.col);\n          // setGrid(newGrid);\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }, 20 * i);\n      }\n    }\n  };\n\n  const animateShortestPath = nodesInShortestPathOrder => {\n    for (let j = 0; j < nodesInShortestPathOrder.length; j++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[j];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest\";\n      }, 50 * j);\n    }\n    setTimeout(() => {\n      setAnimateFlag(false);\n    }, 50 * nodesInShortestPathOrder.length);\n  };\n\n  const clearGrid = () => {\n    setGrid(getInitialGrid());\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (grid[row][col].isStart) {\n          document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n        } else if (grid[row][col].isFinish) {\n          document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n        } else {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    setClearFlag(true);\n    setMazeFlag(false);\n    setAnimateFlag(false);\n  };\n\n  const handleSelection = newAlgoString => {\n    setAlgoString(newAlgoString);\n  };\n\n  const handleWallGeneration = wallString => {\n    let wallAlgo = () => {};\n    let startWithWalls;\n    setMazeFlag(true);\n    switch(wallString) {\n      case 'Recursive Division':\n        wallAlgo = recursiveDivision;\n        startWithWalls = false;\n        break;\n      case 'Binary Tree Maze':\n        wallAlgo = binaryTreeMaze;\n        startWithWalls = true;\n        break;\n      case 'Depth First Search Maze':\n        wallAlgo = depthFirstSearchMaze;\n        startWithWalls = true;\n        break;\n      case \"Randomized Prim's Algorithm\":\n        wallAlgo = randomizedPrimsAlgorithmMaze;\n        startWithWalls = true;\n        break;\n      case 'Default':\n        return;\n    }\n    const copyOfGrid = grid;\n    const startNode = copyOfGrid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = copyOfGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    if (!startWithWalls) {\n      const [newGrid, wallNodesInOrder] = wallAlgo(grid, startNode, finishNode);\n      animateWallAlgo(wallNodesInOrder);\n    } else {\n      const [wallNodesInOrder, nodesInOrder] = wallAlgo(grid, startNode, finishNode);\n      animateFullWalls();\n      setTimeout(() => {animateNodeAlgo(nodesInOrder)}, 20 * Math.ceil(wallNodesInOrder.length / 2));\n    }\n  }\n\n  const animateNodeAlgo = (nodesInOrder) => {\n    for (let i = 0; i < nodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInOrder[i];\n        const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n        setGrid(newGrid);\n        if (!(node.isStart || node.isFinish)) {\n          // document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-intermediate\";\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node\";\n        };\n      }, 50 * i);\n    }\n    setTimeout(() => {\n      setAnimateFlag(false);\n    }, 50 * nodesInOrder.length);\n  }\n\n  const animateFullWalls = () => {\n    setAnimateFlag(true);\n    let i = 0, j = 0, isIncreasing = true, count = 0;\n    const lastRow = grid.length, lastCol = grid[0].length;\n    const nodesInOrder = [];\n    while (i < lastRow) {\n      while (0 <= j && j < lastCol) {\n        const node = grid[i][j];\n        nodesInOrder.push(node);\n        if (isIncreasing) {\n          j++;\n        } else {\n          j--;\n        }\n      }\n      if (isIncreasing) {\n        j--;\n      } else {\n        j++;\n      }\n      isIncreasing = !isIncreasing;\n      i++;\n    }\n    \n    for (let i = 0; i <= nodesInOrder.length - i - 1; i++) {\n      if (i === nodesInOrder.length - i - 1) {\n        setTimeout(() => {\n          const node = nodesInOrder[i];\n          const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n          setGrid(newGrid);\n          if (!(node.isStart || node.isFinish)) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\";\n          };\n        }, 20 * i);\n      } else {\n        setTimeout(() => {\n          const node1 = nodesInOrder[i];\n          const node2 = nodesInOrder[nodesInOrder.length - i - 1];\n          const newGrid1 = getNewGridWithWallToggled(grid, node1.row, node1.col);\n          setGrid(newGrid1);\n          const newGrid2 = getNewGridWithWallToggled(grid, node2.row, node2.col);\n          setGrid(newGrid2);\n  \n          if (!(node1.isStart || node1.isFinish)) {\n            document.getElementById(`node-${node1.row}-${node1.col}`).className = \"node node-wall\";\n          };\n          if (!(node2.isStart || node2.isFinish)) {\n            document.getElementById(`node-${node2.row}-${node2.col}`).className = \"node node-wall\";\n          }\n        }, 20 * i);\n      }\n    }\n  }\n\n  const animateWallAlgo = (wallNodesInOrder) => {\n    setAnimateFlag(true);\n    for (let i = 0; i < wallNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = wallNodesInOrder[i];\n        const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n        setGrid(newGrid);\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-wall\";\n      }, 20 * i);\n    }\n    setTimeout(() => {\n      setAnimateFlag(false);\n    }, 20 * wallNodesInOrder.length);\n  }\n\n  return (\n    <div>\n      <Grid verticalAlign=\"middle\" >\n        <Grid.Column width={3} floated=\"left\">\n          <Container fluid className='sideMenuWrapper'>\n            <SideMenu\n              handleSelection={handleSelection}\n              visualizeAlgorithm={visualizeAlgorithm}\n              clearGrid={clearGrid}\n              handleWallGeneration={handleWallGeneration}\n              animateFlag={animateFlag}\n              mazeFlag={mazeFlag}\n              clearFlag={clearFlag}\n            />\n          </Container>\n        </Grid.Column>\n        <Grid.Column width={13}>\n          <PathFindingGrid\n            algoString={algoString}\n            grid={grid}\n            setGrid={setGrid}\n            getNewGridWithWallToggled={getNewGridWithWallToggled}\n          />\n        </Grid.Column>\n        {/* <Grid.Column className=\"segment centered\" only=\"mobile tablet\">\n          <SmallScreenContainerText />\n        </Grid.Column> */}\n      </Grid>\n    </div>\n  );\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row <= 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col <= 50; col++) {\n      const currentNode = createNode(col, row);\n      currentRow.push(currentNode);\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    gScore: Infinity,\n    fScore: Infinity,\n    isVisited: false,\n    isWall: false,\n    visitedClass: false,\n    previousNode: null,\n    isExplored: false,\n    previousExploredNode: false,\n    isConnected: false\n  };\n};\n\nconst algoReducer = (state, action) => {\n  switch (action.type) {\n    case \"Breadth First Search\":\n      return bfs;\n    case \"A-star Search\":\n      return aStarSearch;\n    case \"A-star Search Min Heap\":\n      return aStarSearchMinHeap\n    case \"Depth First Search\":\n      return dfs;\n    default:\n      return bfs;\n  }\n};\n\nconst getNewGridWithVisitedClass = (grid, row, col) => {\n  const newGrid = grid;\n  const node = newGrid[row][col];\n  if (node.isStart || node.isFinish) return grid;\n  const newNode = {\n    ...node,\n    visitedClass: true\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid;\n  const node = newGrid[row][col];\n  if (node.isStart || node.isFinish) return grid;\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React from \"react\";\nimport {\n  Container,\n  Image,\n  Menu,\n} from \"semantic-ui-react\";\n\nfunction NavigationBar(props) {\n  // const { algoString, handleSelection } = props;\n\n  return (\n    <div>\n      <Menu fixed=\"top\" inverted>\n        <Container>\n          <Menu.Item as=\"a\" href=\"https://www.github.com/samuelwongsy\" header>\n            <Image\n              size=\"mini\"\n              src={require(\"../images/snowflake.svg\")}\n              style={{ marginRight: \"1.5em\" }}\n            />\n            Samuel Wong\n          </Menu.Item>\n          <Menu.Item as=\"a\" href=\"/algo-visualizer\">\n            Algorithm Visualizer\n          </Menu.Item>\n\n          {/* <Dropdown item simple text=\"Pathfinding Visualizer\">\n            <Dropdown.Menu>\n              <Dropdown.Header>Algorithms</Dropdown.Header>\n              <Dropdown.Item\n                value=\"bfs\"\n                onClick={(e, d) => handleSelection(d.value)}\n              >\n                Breadth First Search\n              </Dropdown.Item>\n              <Dropdown.Item\n                value=\"a-star\"\n                onClick={(e, d) => handleSelection(d.value)}\n              >\n                A* Search\n              </Dropdown.Item>\n            </Dropdown.Menu>\n          </Dropdown>\n          <Menu.Item>Visualizing: {algoString}</Menu.Item> */}\n        </Container>\n      </Menu>\n    </div>\n  );\n}\n\nexport default NavigationBar;\n","import React from \"react\";\nimport PathFindingVisualizer from \"./PathFindingVisualizer/PathFindingVisualizer\";\nimport NavigationBar from \"./NavigationBar\";\nimport SmallScreenContainerText from \"./PathFindingVisualizer/SmallScreenContainerText\";\nimport { Container, Grid } from \"semantic-ui-react\";\n\nexport default function HomePage() {\n  return (\n    <div>\n      <Grid divided='vertically' style={{height: '1000px', backgroundColor: \"rgb(32,32,32)\"}}>\n        <Grid.Row style={{height: '7%'}}>\n          <NavigationBar />\n        </Grid.Row>\n        <Grid.Row style={{height: '100%', backgroundColor: \"rgb(32,32,32)\"}}>\n          <PathFindingVisualizer />\n        </Grid.Row>\n      </Grid>\n    </div>\n  );\n}\n","import React from \"react\";\nimport HomePage from \"./components/HomePage\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <HomePage />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport \"semantic-ui-css/semantic.min.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}