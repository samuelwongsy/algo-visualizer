{"version":3,"sources":["images/snowflake.svg","components/PathFindingVisualizer/PathFindingGrid/Node/Node.jsx","components/PathFindingVisualizer/PathFindingGrid/PathFindingGrid.jsx","components/PathFindingVisualizer/SideMenu.jsx","algorithms/path-finding-algorithms/breath-first-search.js","algorithms/path-finding-algorithms/a-star-search-queue.js","algorithms/path-finding-algorithms/a-star-search.js","algorithms/data-structures/MinHeap.js","algorithms/path-finding-algorithms/depth-first-search.js","algorithms/maze-generation-algorithms/recursive-division.js","algorithms/maze-generation-algorithms/binary-tree-maze.js","algorithms/maze-generation-algorithms/depth-first-search-maze.js","components/PathFindingVisualizer/PathFindingVisualizer.jsx","components/NavigationBar.jsx","components/HomePage.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","props","row","col","isFinish","isStart","isWall","isVisited","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","PathFindingGrid","useState","mouseDown","setMouseDown","grid","setGrid","getNewGridWithWallToggled","handleClick","newGrid","map","rowIndex","key","node","colIndex","visitedClass","handleMouseDown","handleMouseEnter","onClick","SideMenu","state","activeItem","activeWall","handleItemClick","e","name","setState","handleSelection","handleWallAlgoClick","handleWallGeneration","clearGrid","this","visualizeAlgorithm","Menu","fluid","inverted","vertical","size","Item","active","Button","secondary","icon","labelPosition","Icon","Component","updateUnvisitedNeighbours","queue","unvisitedNeighbours","neighbours","push","length","filter","getUnvisitedNeighbours","neighbour","previousNode","bfs","FINISH_NODE_ROW","FINISH_NODE_COL","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","currentNode","shift","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","getHeuristics","Math","abs","updateNeighbours","getNeighbours","tentativeGScore","gScore","distance","includes","sort","a","b","aStarSearch","openNodes","MinHeap","array","heap","buildHeap","currentIdx","floor","siftDown","endIdx","childOneIdx","childTwoIdx","idxToSwap","swap","parentIdx","valueToRemove","pop","value","siftUp","i","j","temp","minHeap","insert","remove","stack","dfs","getRandomInt","min","max","result","random","flag","recursiveDivision","wallNodesInOrder","wallNodesSet","Set","endRow","endCol","add","divisionHelper","startRow","startCol","typeOfDivide","height","width","tries","override","openRowOverride","has","openRow","openColOverride","openCol","connect","neighbourNode","binaryTreeMaze","nodesInOrder","randomIndex","getUnvisitedNeighboursInRandomOrder","isExplored","randomNode","previousExploredNode","splice","depthFirstSearchMaze","PathFindingVisualizer","getInitialGrid","algoString","setAlgoString","useReducer","algoReducer","algorithm","dispatch","useEffect","type","animateAlgorithm","setTimeout","animateShortestPath","document","getElementById","animateNodeAlgo","animateFullWalls","isIncreasing","lastRow","lastCol","node1","node2","newGrid1","newGrid2","animateWallAlgo","Grid","verticalAlign","Column","floated","Container","newAlgoString","console","log","copyOfGrid","wallString","startWithWalls","wallAlgo","ceil","currentRow","createNode","Infinity","fScore","action","aStarSearchMinHeap","newNode","NavigationBar","fixed","as","href","header","Image","src","require","style","marginRight","HomePage","divided","backgroundColor","Row","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.fb45adf7.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/snowflake.6114f6e9.svg\";","import React, { useState } from \"react\";\nimport \"./Node.css\";\n\nfunction Node(props) {\n  const {\n    row,\n    col,\n    isFinish,\n    isStart,\n    isWall,\n    isVisited,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n  } = props;\n\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : isVisited\n    ? \"node-visited\"\n    : \"\";\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseUp={() => onMouseUp()}\n    ></div>\n  );\n}\n\nexport default Node;\n","import React, { useState, useEffect } from \"react\";\nimport Node from \"./Node/Node\";\nimport \"./PathFindingGrid.css\";\n\nfunction PathFindingGrid(props) {\n  const [mouseDown, setMouseDown] = useState(false);\n  const { grid, setGrid, getNewGridWithWallToggled } = props;\n\n  // useEffect(() => {\n  //   for (let row = 0; row < grid.length; row++) {\n  //     for (let col = 0; col < grid[0].length; col++) {\n  //       document.getElementById(`node-${row}-${col}`).className = \"node\";\n  //     }\n  //   }\n  // }, [grid]);\n\n  const handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setMouseDown(true);\n    setGrid(newGrid);\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseDown) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  const handleMouseUp = () => {\n    setMouseDown(false);\n  };\n\n  const handleClick = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n\n  return (\n    <div>\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => {\n          return (\n            <div key={rowIndex} className=\"row\">\n              {row.map((node, colIndex) => (\n                <Node\n                  key={[node.col, node.row]}\n                  isStart={node.isStart}\n                  isFinish={node.isFinish}\n                  isWall={node.isWall}\n                  isVisited={node.visitedClass}\n                  // mousePressed={mouseDown}\n                  onMouseDown={(row, col) => handleMouseDown(row, col)}\n                  onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                  onMouseUp={() => handleMouseUp()}\n                  onClick={handleClick}\n                  row={node.row}\n                  col={node.col}\n                />\n              ))}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\n\nexport default PathFindingGrid;\n","import React, { Component } from \"react\";\nimport { Menu, Button, Icon } from \"semantic-ui-react\";\n\nexport default class SideMenu extends Component {\n  state = { \n    activeItem: \"Breadth First Search\",\n    activeWall: \"Default\"\n  };\n\n  handleItemClick = (e, { name }) => {\n    this.setState({ activeItem: name });\n    this.props.handleSelection(name);\n  };\n\n  handleWallAlgoClick = (e, { name }) => {\n    this.setState({ activeWall: name });\n    this.props.handleWallGeneration(name);\n  }\n\n  clearGrid = (e) => {\n    this.setState({ activeWall: \"Default\" });\n    this.props.clearGrid();\n  }\n\n  render() {\n    const { activeItem, activeWall } = this.state;\n    const { visualizeAlgorithm, clearGrid } = this.props;\n\n    return (\n      <Menu fluid inverted vertical size=\"large\">\n        <Menu.Item>\n          Algorithms\n          <Menu.Menu>\n            <Menu.Item\n              name=\"Breadth First Search\"\n              active={activeItem === \"Breadth First Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"Depth First Search\"\n              active={activeItem === \"Depth First Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"A-star Search\"\n              active={activeItem === \"A-star Search\"}\n              onClick={this.handleItemClick}\n            />\n            <Menu.Item\n              name=\"A-star Search Min Heap\"\n              active={activeItem === \"A-star Search Min Heap\"}\n              onClick={this.handleItemClick}\n            />\n          </Menu.Menu>\n        </Menu.Item>\n\n        <Menu.Item>\n          Wall Generation\n          <Menu.Menu>\n            <Menu.Item \n              name=\"Recursive Division\"\n              active={activeWall === \"Recursive Division\"}\n              onClick={this.handleWallAlgoClick}\n            />\n            <Menu.Item \n              name=\"Binary Tree Maze\"\n              active={activeWall === \"Binary Tree Maze\"}\n              onClick={this.handleWallAlgoClick}\n            />\n            <Menu.Item \n              name=\"Depth First Search Maze\"\n              active={activeWall === \"Depth First Search Maze\"}\n              onClick={this.handleWallAlgoClick}\n            />\n          </Menu.Menu>\n        </Menu.Item>\n\n        {/* <Menu.Item\n          name=\"home\"\n          active={activeItem === \"home\"}\n          onClick={this.handleItemClick}\n        />\n        <Menu.Item\n          name=\"messages\"\n          active={activeItem === \"messages\"}\n          onClick={this.handleItemClick}\n        />\n        <Menu.Item\n          name=\"friends\"\n          active={activeItem === \"friends\"}\n          onClick={this.handleItemClick}\n        /> */}\n        <Menu.Item>\n          <Button\n            fluid\n            secondary\n            icon\n            labelPosition=\"right\"\n            onClick={visualizeAlgorithm}\n          >\n            Visualize\n            <Icon name=\"caret square right\" />\n          </Button>\n        </Menu.Item>\n        <Menu.Item>\n          <Button\n            fluid\n            secondary\n            icon\n            labelPosition=\"right\"\n            onClick={this.clearGrid}\n          >\n            Clear\n            <Icon name=\"redo alternate\" />\n          </Button>\n        </Menu.Item>\n      </Menu>\n    );\n  }\n}\n","// Breath-first search using a queue\n\nfunction bfs(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return [[], []];\n  }\n\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = []; // queue\n  unvisitedNodes.push(startNode);\n\n  while (!!unvisitedNodes.length) {\n    const currentNode = unvisitedNodes.shift();\n\n    if (currentNode.isWall) continue;\n\n    if (currentNode.isVisited) continue;\n\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === finishNode) break;\n\n    updateUnvisitedNeighbours(currentNode, unvisitedNodes, grid);\n  }\n\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n  // console.log(visitedNodesInOrder);\n\n  return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction updateUnvisitedNeighbours(node, queue, grid) {\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of unvisitedNeighbours) {\n    neighbour.previousNode = node;\n    queue.push(neighbour);\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const {\n    col,\n    row\n  } = node;\n\n  const neighbours = [];\n\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n  return neighbours.filter(node => !node.isVisited);\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n  if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nexport default bfs;","// a-star search using manhatten distance heuristics\n// not using visited because a-star search allows you to reach a visited node with\n// a lower distance\n\nlet FINISH_NODE_ROW;\nlet FINISH_NODE_COL;\n\nfunction aStarSearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n\n    FINISH_NODE_ROW = finishNode.row;\n    FINISH_NODE_COL = finishNode.col;\n\n    const visitedNodesInOrder = [];\n    const openNodes = [];\n    openNodes.push(startNode);\n    while (!!openNodes.length) {\n        const currentNode = openNodes.shift();\n\n        if (currentNode === startNode) {\n            currentNode.gScore = 0;\n            currentNode.distance = getHeuristics(currentNode);\n        }\n\n        if (currentNode.isWall) continue;\n\n        visitedNodesInOrder.push(currentNode);\n\n        if (currentNode === finishNode) {\n            finishNode.isVisited = true;\n            break;\n        }\n\n        updateNeighbours(currentNode, openNodes, grid);\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    // console.log(visitedNodesInOrder);\n\n    return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction getHeuristics(node) {\n    const distance = Math.abs(node.row - FINISH_NODE_ROW) +\n        Math.abs(node.col - FINISH_NODE_COL);\n\n    return distance\n}\n\nfunction updateNeighbours(node, queue, grid) {\n    const neighbours = getNeighbours(node, grid);\n\n    for (const neighbour of neighbours) {\n        const tentativeGScore = node.gScore + 1;\n        if (tentativeGScore < neighbour.gScore) {\n            neighbour.previousNode = node;\n            neighbour.gScore = tentativeGScore;\n            neighbour.distance = neighbour.gScore + getHeuristics(neighbour);\n            if (!queue.includes(neighbour)) queue.push(neighbour);\n        }\n    }\n    queue.sort((a, b) => a.distance - b.distance);\n}\n\nfunction getNeighbours(node, grid) {\n    const {\n        col,\n        row\n    } = node;\n\n    const neighbours = [];\n\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n    return neighbours;\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n    // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n    if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport default aStarSearch;","import MinHeap from '../data-structures/MinHeap';\n// a-star search using manhatten distance heuristics\n// not using visited because a-star search allows you to reach a visited node with\n// a lower distance\n\nlet FINISH_NODE_ROW;\nlet FINISH_NODE_COL;\n\nfunction aStarSearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n\n    FINISH_NODE_ROW = finishNode.row;\n    FINISH_NODE_COL = finishNode.col;\n\n    const visitedNodesInOrder = [];\n    const openNodes = new MinHeap([]);\n    openNodes.insert(startNode);\n    while (!!openNodes.heap.length) {\n        // console.log(openNodes.heap);\n        const currentNode = openNodes.remove();\n\n        if (currentNode === startNode) {\n            currentNode.gScore = 0;\n            currentNode.distance = getHeuristics(currentNode);\n        }\n\n        if (currentNode.isWall) continue;\n\n        visitedNodesInOrder.push(currentNode);\n\n        if (currentNode === finishNode) {\n            finishNode.isVisited = true;\n            break;\n        }\n\n        updateNeighbours(currentNode, openNodes, grid);\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    // console.log(visitedNodesInOrder);\n\n    return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction getHeuristics(node) {\n    const distance = Math.abs(node.row - FINISH_NODE_ROW) +\n        Math.abs(node.col - FINISH_NODE_COL);\n\n    return distance\n}\n\nfunction updateNeighbours(node, minHeap, grid) {\n    const neighbours = getNeighbours(node, grid);\n\n    for (const neighbour of neighbours) {\n        const tentativeGScore = node.gScore + 1;\n        if (tentativeGScore < neighbour.gScore) {\n            neighbour.previousNode = node;\n            neighbour.gScore = tentativeGScore;\n            neighbour.distance = neighbour.gScore + getHeuristics(neighbour);\n            if (!minHeap.heap.includes(neighbour)) minHeap.insert(neighbour);\n        }\n    }\n}\n\nfunction getNeighbours(node, grid) {\n    const {\n        col,\n        row\n    } = node;\n\n    const neighbours = [];\n\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n    return neighbours;\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n    // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n    if (!finishNode.isVisited && !finishNode.previousNode) return [];\n\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport default aStarSearch;","class MinHeap {\n    constructor(array) {\n        this.heap = this.buildHeap(array);\n    }\n\n    // O(n) time | O(1) space\n    buildHeap(array) {\n        const firstParentIdx = Math.floor((array.length - 2) / 2);\n        for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n            this.siftDown(currentIdx, array.length - 1, array);\n        }\n        return array;\n\n    }\n\n    // O(log(n)) time | O(1) space\n    siftDown(currentIdx, endIdx, heap) {\n        let childOneIdx = currentIdx * 2 + 1;\n        while (childOneIdx <= endIdx) {\n            const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n            let idxToSwap;\n            if (childTwoIdx !== -1 && heap[childTwoIdx].distance < heap[childOneIdx].distance) {\n                idxToSwap = childTwoIdx;\n            } else {\n                idxToSwap = childOneIdx;\n            }\n            if (heap[idxToSwap].distance < heap[currentIdx].distance) {\n                this.swap(currentIdx, idxToSwap, heap);\n                currentIdx = idxToSwap;\n                childOneIdx = currentIdx * 2 + 1;\n            } else {\n                return;\n            }\n        }\n\n    }\n\n    // O(log(n)) time | O(1) space\n    siftUp(currentIdx, heap) {\n        let parentIdx = Math.floor((currentIdx - 1) / 2);\n        while (currentIdx > 0 && heap[currentIdx].distance < heap[parentIdx].distance) {\n            this.swap(currentIdx, parentIdx, heap);\n            currentIdx = parentIdx;\n            parentIdx = Math.floor((currentIdx - 1) / 2);\n        }\n    }\n\n    // O(1) time | O(1) space\n    peek() {\n        return this.heap[0];\n    }\n\n    // O(log(n)) time | O(1) space\n    remove() {\n        this.swap(0, this.heap.length - 1, this.heap);\n        const valueToRemove = this.heap.pop();\n        this.siftDown(0, this.heap.length - 1, this.heap);\n        return valueToRemove;\n    }\n\n    // O(log(n)) time | O(1) space\n    insert(value) {\n        this.heap.push(value);\n        this.siftUp(this.heap.length - 1, this.heap);\n    }\n\n    swap(i, j, heap) {\n        const temp = heap[j];\n        heap[j] = heap[i];\n        heap[i] = temp;\n    }\n}\n\n// Do not edit the line below.\nexport default MinHeap;","// Depth-first search using a stack\n\nfunction dfs(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n\n    const visitedNodesInOrder = [];\n    const unvisitedNodes = []; //stack\n    unvisitedNodes.push(startNode);\n\n    while (!!unvisitedNodes.length) {\n        const currentNode = unvisitedNodes.pop();\n\n        if (currentNode.isWall) continue;\n\n        if (currentNode.isVisited) continue;\n\n        currentNode.isVisited = true;\n        visitedNodesInOrder.push(currentNode);\n\n        if (currentNode === finishNode) break;\n\n        updateUnvisitedNeighbours(currentNode, unvisitedNodes, grid);\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n    return [visitedNodesInOrder, nodesInShortestPathOrder];\n}\n\nfunction updateUnvisitedNeighbours(node, stack, grid) {\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n    for (const neighbour of unvisitedNeighbours) {\n        neighbour.previousNode = node;\n        stack.push(neighbour);\n    }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n    const {\n        col,\n        row\n    } = node;\n\n    const neighbours = [];\n\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\n    return neighbours.filter(node => !node.isVisited);\n}\n\nfunction getNodesInShortestPathOrder(finishNode) {\n    // If we didn't visit finishNode or doesn't have a valid path, return empty list.\n    if (!finishNode.isVisited && !finishNode.previousNode) return [];\n  \n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport default dfs;","function recursiveDivision(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [grid, []];\n    }\n    const newGrid = grid;\n    const wallNodesInOrder = [];\n    const wallNodesSet = new Set();\n    \n    const startRow = 0;\n    const startCol = 0;\n    const endRow = grid.length-1;\n    const endCol = grid[0].length-1;\n    // inital boundary\n    for (let col = 0; col < grid[0].length; col++) {\n        const currentNode = grid[0][col];\n        wallNodesInOrder.push(currentNode);\n        wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n\n    for (let row = 1; row < grid.length-1; row++) {\n        const currentNode = grid[row][endCol];\n        wallNodesInOrder.push(currentNode);\n        wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n\n    for (let col = endCol; col >= 0; col--) {\n        const currentNode = grid[endRow][col];\n        wallNodesInOrder.push(currentNode);\n        wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n\n    for (let row = endRow - 1; row > 0; row--) {\n        const currentNode = grid[row][startCol];\n        wallNodesInOrder.push(currentNode);\n        wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n    }\n\n    divisionHelper(newGrid, startRow+1, endRow-1, startCol+1, endCol-1, wallNodesInOrder, wallNodesSet);\n\n    return [newGrid, wallNodesInOrder]\n}\n\nfunction divisionHelper(grid, startRow, endRow, startCol, endCol, wallNodesInOrder, wallNodesSet) {\n    // if (startRow >= endRow - 2) return;\n    // if (startCol >= endCol - 2) return;\n\n    const height = endRow - startRow;\n    const width = endCol - startCol;\n\n    if (height <= 1 && width <= 1) return;\n    \n    let typeOfDivide;\n    if (width >= height) {\n        typeOfDivide = 'vertical';\n    } else {\n        typeOfDivide = 'horizontal';\n    }\n\n    if (height === 3 && typeOfDivide === 'vertical') {\n        typeOfDivide = 'horizontal';\n    } else if (width === 3 && typeOfDivide === 'horizontal') {\n        typeOfDivide = 'vertical';\n    }\n\n    if (typeOfDivide === 'vertical') {\n        let col = getRandomInt(startCol+1, endCol-1), tries = 10;\n        let override = false, openRowOverride = -1;\n        while (!(wallNodesSet.has(`${startRow-1}-${col}`) && wallNodesSet.has(`${endRow+1}-${col}`))) {\n            if (!wallNodesSet.has(`${startRow-1}-${col}`) && wallNodesSet.has(`${endRow+1}-${col}`)) {\n                openRowOverride = startRow;\n                override = true;\n                break;\n            } else if (wallNodesSet.has(`${startRow-1}-${col}`) && !wallNodesSet.has(`${endRow+1}-${col}`)) {\n                openRowOverride = endRow;\n                override = true;\n                break;\n            }\n            if (tries === 0) return;\n            col = getRandomInt(startCol+1, endCol-1);\n            tries--;\n        }\n        // const col = Math.floor((startCol + endCol) / 2);\n        let openRow = getRandomInt(startRow, endRow);\n        if (override) openRow = openRowOverride;\n        for (let row = startRow; row <= endRow; row++) {\n            if (row === openRow) continue;\n            const currentNode = grid[row][col];\n            if (currentNode.isStart || currentNode.isFinish) continue;\n            wallNodesInOrder.push(currentNode);\n            wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n        }\n        divisionHelper(grid, startRow, endRow, startCol, col-1, wallNodesInOrder, wallNodesSet);\n        divisionHelper(grid, startRow, endRow, col+1, endCol, wallNodesInOrder, wallNodesSet);\n    } else if (typeOfDivide === 'horizontal') {\n        let row = getRandomInt(startRow+1, endRow-1), tries = 10;\n        let override = false, openColOverride = -1;\n        while (!(wallNodesSet.has(`${row}-${startCol-1}`) && wallNodesSet.has(`${row}-${endCol+1}`))) {\n            if (!wallNodesSet.has(`${row}-${startCol-1}`) && wallNodesSet.has(`${row}-${endCol+1}`)) {\n                openColOverride = startCol;\n                override = true;\n                break;\n            } else if (wallNodesSet.has(`${row}-${startCol-1}`) && !wallNodesSet.has(`${row}-${endCol+1}`)) {\n                openColOverride = endCol;\n                override = true;\n            }\n            if (tries === 0) return;\n            row = getRandomInt(startRow+1, endRow-1);\n            tries--;\n        }\n        // const row = Math.floor((startRow + endRow) / 2);\n        let openCol = getRandomInt(startCol, endCol);\n        if (override) openCol = openColOverride;\n        for (let col = startCol; col <= endCol; col++) {\n            if (col === openCol) continue;\n            const currentNode = grid[row][col];\n            if (currentNode.isStart || currentNode.isFinish) continue;\n            wallNodesInOrder.push(currentNode);\n            wallNodesSet.add(`${currentNode.row}-${currentNode.col}`);\n        }\n        divisionHelper(grid, startRow, row-1, startCol, endCol, wallNodesInOrder, wallNodesSet);\n        divisionHelper(grid, row+1, endRow, startCol, endCol, wallNodesInOrder, wallNodesSet);\n    }\n}\n\nfunction getRandomInt(min, max) {\n    let result = Math.floor(Math.random() * Math.floor(max - min)) + min;\n    if (max-1 === min) {\n        const flag = Math.random();\n        if (flag <= 0.5) return min;\n        if (flag > 0.5) return max;\n    }\n    return result;\n}\n\nexport default recursiveDivision;","function binaryTreeMaze(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n    // const newGrid = grid;\n    const wallNodesInOrder = [];\n\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[0].length; col++) {\n            const node = grid[row][col];\n            if (node.isStart || node.isFinish) continue;\n            wallNodesInOrder.push(node);\n        }\n    }\n    const nodesInOrder = [];\n\n    const startRow = 1;\n    const startCol = 1;\n    const endRow = grid.length-2;\n    const endCol = grid[0].length-2;\n\n    for (let row = 1; row <= endRow; row = row + 2) {\n        for (let col = 1; col <= endCol; col = col + 2) {\n            const currentNode = grid[row][col];\n            nodesInOrder.push(currentNode);\n            \n            const neighbours = [];\n            if (row > startRow) neighbours.push(grid[row-2][col]);\n            if (col > startCol) neighbours.push(grid[row][col-2]);\n\n            if (neighbours.length === 0) continue;\n\n            let randomIndex;\n            if (Math.random() < 0.5) {\n                randomIndex = 0 % neighbours.length;\n            } else {\n                randomIndex = 1 % neighbours.length;\n            }\n\n            nodesInOrder.push(connect(currentNode, neighbours[randomIndex], grid));\n        }\n    }\n\n    return [wallNodesInOrder, nodesInOrder];\n}\n\nfunction connect(currentNode, neighbourNode, grid) {\n    let row = Math.floor((currentNode.row + neighbourNode.row) / 2);\n    let col = Math.floor((currentNode.col + neighbourNode.col) / 2);\n    return grid[row][col];\n}\n\nexport default binaryTreeMaze;","function depthFirstSearchMaze(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return [[], []];\n    }\n\n    const wallNodesInOrder = [];\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[0].length; col++) {\n            const node = grid[row][col];\n            if (node.isStart || node.isFinish) continue;\n            wallNodesInOrder.push(node);\n        }\n    }\n\n    const nodesInOrder = [];\n    const stack = [];\n    stack.push(startNode);\n\n    while (!!stack.length) {\n        const currentNode = stack.pop();\n\n        if (currentNode.isExplored) continue;\n\n        currentNode.isExplored = true;\n        nodesInOrder.push(currentNode);\n        if (!!currentNode.previousExploredNode) {\n            nodesInOrder.push(connect(currentNode, currentNode.previousExploredNode, grid));\n        }\n        getUnvisitedNeighboursInRandomOrder(currentNode, stack, grid);\n    }\n\n    return [wallNodesInOrder, nodesInOrder];\n}\n\nfunction getUnvisitedNeighboursInRandomOrder(node, stack, grid) {\n    const unvisitedNeighbours = [];\n    const row = node.row, col = node.col;\n\n    if (row > 2 && !grid[row-2][col].isExplored) unvisitedNeighbours.push(grid[row-2][col]);\n    if (col > 2 && !grid[row][col-2].isExplored) unvisitedNeighbours.push(grid[row][col-2]);\n    if (row < grid.length-3 && !grid[row+2][col].isExplored) unvisitedNeighbours.push(grid[row+2][col]);\n    if (col < grid[0].length-3 && !grid[row][col+2].isExplored) unvisitedNeighbours.push(grid[row][col+2]);\n\n    while (!!unvisitedNeighbours.length) {\n        const randomIndex = Math.floor(Math.random() * unvisitedNeighbours.length);\n        const randomNode = unvisitedNeighbours[randomIndex];\n        randomNode.previousExploredNode = node;\n        stack.push(randomNode);\n        unvisitedNeighbours.splice(randomIndex, 1);\n    }\n}\n\nfunction connect(currentNode, neighbourNode, grid) {\n    let row = Math.floor((currentNode.row + neighbourNode.row) / 2);\n    let col = Math.floor((currentNode.col + neighbourNode.col) / 2);\n    return grid[row][col];\n}\n\nexport default depthFirstSearchMaze;","import React, { useState, useReducer, useEffect } from \"react\";\nimport \"./PathFindingVisualizer.css\";\nimport PathFindingGrid from \"./PathFindingGrid/PathFindingGrid\";\nimport SideMenu from \"./SideMenu\";\nimport SmallScreenContainerText from \"./SmallScreenContainerText\";\nimport { Container, Grid } from \"semantic-ui-react\";\nimport bfs from \"../../algorithms/path-finding-algorithms/breath-first-search\";\nimport aStarSearch from \"../../algorithms/path-finding-algorithms/a-star-search-queue\";\nimport aStarSearchMinHeap from \"../../algorithms/path-finding-algorithms/a-star-search\";\nimport dfs from \"../../algorithms/path-finding-algorithms/depth-first-search\";\nimport recursiveDivision from \"../../algorithms/maze-generation-algorithms/recursive-division\";\nimport binaryTreeMaze from \"../../algorithms/maze-generation-algorithms/binary-tree-maze\";\nimport depthFirstSearchMaze from \"../../algorithms/maze-generation-algorithms/depth-first-search-maze\";\n\nconst START_NODE_ROW = 11;\nconst START_NODE_COL = 5;\nconst FINISH_NODE_ROW = 11;\nconst FINISH_NODE_COL = 45;\n\nexport default function PathFindingVisualizer() {\n  const [grid, setGrid] = useState(getInitialGrid());\n  const [algoString, setAlgoString] = useState(\"Breadth First Search\");\n  const [algorithm, dispatch] = useReducer(algoReducer, bfs);\n\n  useEffect(() => {\n    dispatch({ type: algoString });\n  }, [algoString]);\n\n  const visualizeAlgorithm = () => {\n    const copyOfGrid = grid;\n    const algoToVisualize = algorithm;\n    const startNode = copyOfGrid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = copyOfGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const [visitedNodesInOrder, nodesInShortestPathOrder] = algoToVisualize(\n      copyOfGrid,\n      startNode,\n      finishNode\n    );\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      } else {\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          // const newGrid = getNewGridWithVisitedClass(grid, node.row, node.col);\n          // setGrid(newGrid);\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }, 20 * i);\n      }\n    }\n  };\n\n  const animateShortestPath = nodesInShortestPathOrder => {\n    for (let j = 0; j < nodesInShortestPathOrder.length; j++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[j];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest\";\n      }, 50 * j);\n    }\n  };\n\n  const clearGrid = () => {\n    setGrid(getInitialGrid());\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (grid[row][col].isStart) {\n          document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n        } else if (grid[row][col].isFinish) {\n          document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n        } else {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n  };\n\n  const handleSelection = newAlgoString => {\n    setAlgoString(newAlgoString);\n    console.log(newAlgoString);\n  };\n\n  const handleWallGeneration = wallString => {\n    let wallAlgo = () => {};\n    let startWithWalls;\n    if (wallString === 'Default'){\n      return;\n    } else if (wallString === 'Recursive Division') {\n      wallAlgo = recursiveDivision;\n      startWithWalls = false;\n    } else if (wallString === 'Binary Tree Maze') {\n      wallAlgo = binaryTreeMaze;\n      startWithWalls = true;\n    } else if (wallString === 'Depth First Search Maze') {\n      wallAlgo = depthFirstSearchMaze;\n      startWithWalls = true;\n    }\n\n    const copyOfGrid = grid;\n    const startNode = copyOfGrid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = copyOfGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    if (!startWithWalls) {\n      const [newGrid, wallNodesInOrder] = wallAlgo(grid, startNode, finishNode);\n      animateWallAlgo(wallNodesInOrder);\n    } else {\n      const [wallNodesInOrder, nodesInOrder] = wallAlgo(grid, startNode, finishNode);\n      animateFullWalls();\n      setTimeout(() => {animateNodeAlgo(nodesInOrder)}, 20 * Math.ceil(wallNodesInOrder.length / 2));\n    }\n  }\n\n  const animateNodeAlgo = (nodesInOrder) => {\n    for (let i = 0; i < nodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInOrder[i];\n        const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n        setGrid(newGrid);\n        if (!(node.isStart || node.isFinish)) {\n          // document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-intermediate\";\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node\";\n        };\n      }, 50 * i);\n    }\n  }\n\n  const animateFullWalls = () => {\n    let i = 0, j = 0, isIncreasing = true, count = 0;\n    const lastRow = grid.length, lastCol = grid[0].length;\n    const nodesInOrder = [];\n    while (i < lastRow) {\n      while (0 <= j && j < lastCol) {\n        const node = grid[i][j];\n        nodesInOrder.push(node);\n        if (isIncreasing) {\n          j++;\n        } else {\n          j--;\n        }\n      }\n      if (isIncreasing) {\n        j--;\n      } else {\n        j++;\n      }\n      isIncreasing = !isIncreasing;\n      i++;\n    }\n    \n    for (let i = 0; i <= nodesInOrder.length - i - 1; i++) {\n      if (i === nodesInOrder.length - i - 1) {\n        setTimeout(() => {\n          const node = nodesInOrder[i];\n          const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n          setGrid(newGrid);\n          if (!(node.isStart || node.isFinish)) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\";\n          };\n        }, 20 * i);\n      } else {\n        setTimeout(() => {\n          const node1 = nodesInOrder[i];\n          const node2 = nodesInOrder[nodesInOrder.length - i - 1];\n          const newGrid1 = getNewGridWithWallToggled(grid, node1.row, node1.col);\n          setGrid(newGrid1);\n          const newGrid2 = getNewGridWithWallToggled(grid, node2.row, node2.col);\n          setGrid(newGrid2);\n  \n          if (!(node1.isStart || node1.isFinish)) {\n            document.getElementById(`node-${node1.row}-${node1.col}`).className = \"node node-wall\";\n          };\n          if (!(node2.isStart || node2.isFinish)) {\n            document.getElementById(`node-${node2.row}-${node2.col}`).className = \"node node-wall\";\n          }\n        }, 20 * i);\n      }\n    }\n  }\n\n  const animateWallAlgo = (wallNodesInOrder) => {\n    for (let i = 0; i < wallNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = wallNodesInOrder[i];\n        const newGrid = getNewGridWithWallToggled(grid, node.row, node.col);\n        setGrid(newGrid);\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-wall\";\n      }, 20 * i);\n    }\n  }\n\n  return (\n    <div>\n      <Grid verticalAlign=\"middle\" >\n        <Grid.Column width={3} floated=\"left\">\n          <Container fluid className='sideMenuWrapper'>\n            <SideMenu\n              handleSelection={handleSelection}\n              visualizeAlgorithm={visualizeAlgorithm}\n              clearGrid={clearGrid}\n              handleWallGeneration={handleWallGeneration}\n            />\n          </Container>\n        </Grid.Column>\n        <Grid.Column width={13}>\n          <PathFindingGrid\n            algoString={algoString}\n            grid={grid}\n            setGrid={setGrid}\n            getNewGridWithWallToggled={getNewGridWithWallToggled}\n          />\n        </Grid.Column>\n        {/* <Grid.Column className=\"segment centered\" only=\"mobile tablet\">\n          <SmallScreenContainerText />\n        </Grid.Column> */}\n      </Grid>\n    </div>\n  );\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row <= 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col <= 50; col++) {\n      const currentNode = createNode(col, row);\n      currentRow.push(currentNode);\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    gScore: Infinity,\n    fScore: Infinity,\n    isVisited: false,\n    isWall: false,\n    visitedClass: false,\n    previousNode: null,\n    isExplored: false,\n    previousExploredNode: false\n  };\n};\n\nconst algoReducer = (state, action) => {\n  switch (action.type) {\n    case \"Breadth First Search\":\n      return bfs;\n    case \"A-star Search\":\n      return aStarSearch;\n    case \"A-star Search Min Heap\":\n      return aStarSearchMinHeap\n    case \"Depth First Search\":\n      return dfs;\n    default:\n      return bfs;\n  }\n};\n\nconst getNewGridWithVisitedClass = (grid, row, col) => {\n  const newGrid = grid;\n  const node = newGrid[row][col];\n  if (node.isStart || node.isFinish) return grid;\n  const newNode = {\n    ...node,\n    visitedClass: true\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid;\n  const node = newGrid[row][col];\n  if (node.isStart || node.isFinish) return grid;\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React from \"react\";\nimport {\n  Container,\n  Image,\n  Menu,\n} from \"semantic-ui-react\";\n\nfunction NavigationBar(props) {\n  // const { algoString, handleSelection } = props;\n\n  return (\n    <div>\n      <Menu fixed=\"top\" inverted>\n        <Container>\n          <Menu.Item as=\"a\" href=\"https://www.github.com/samuelwongsy\" header>\n            <Image\n              size=\"mini\"\n              src={require(\"../images/snowflake.svg\")}\n              style={{ marginRight: \"1.5em\" }}\n            />\n            Samuel Wong\n          </Menu.Item>\n          <Menu.Item as=\"a\" href=\"/algo-visualizer\">\n            Algorithm Visualizer\n          </Menu.Item>\n\n          {/* <Dropdown item simple text=\"Pathfinding Visualizer\">\n            <Dropdown.Menu>\n              <Dropdown.Header>Algorithms</Dropdown.Header>\n              <Dropdown.Item\n                value=\"bfs\"\n                onClick={(e, d) => handleSelection(d.value)}\n              >\n                Breadth First Search\n              </Dropdown.Item>\n              <Dropdown.Item\n                value=\"a-star\"\n                onClick={(e, d) => handleSelection(d.value)}\n              >\n                A* Search\n              </Dropdown.Item>\n            </Dropdown.Menu>\n          </Dropdown>\n          <Menu.Item>Visualizing: {algoString}</Menu.Item> */}\n        </Container>\n      </Menu>\n    </div>\n  );\n}\n\nexport default NavigationBar;\n","import React from \"react\";\nimport PathFindingVisualizer from \"./PathFindingVisualizer/PathFindingVisualizer\";\nimport NavigationBar from \"./NavigationBar\";\nimport SmallScreenContainerText from \"./PathFindingVisualizer/SmallScreenContainerText\";\nimport { Container, Grid } from \"semantic-ui-react\";\n\nexport default function HomePage() {\n  return (\n    <div>\n      <Grid divided='vertically' style={{height: '1000px', backgroundColor: \"rgb(32,32,32)\"}}>\n        <Grid.Row style={{height: '7%'}}>\n          <NavigationBar />\n        </Grid.Row>\n        <Grid.Row style={{height: '100%', backgroundColor: \"rgb(32,32,32)\"}}>\n          <PathFindingVisualizer />\n        </Grid.Row>\n      </Grid>\n    </div>\n  );\n}\n","import React from \"react\";\nimport HomePage from \"./components/HomePage\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <HomePage />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport \"semantic-ui-css/semantic.min.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}